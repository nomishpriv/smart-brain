{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RetryingCall = exports.MessageBufferTracker = exports.RetryThrottler = void 0;\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst logging = require(\"./logging\");\nconst TRACER_NAME = 'retrying_call';\nclass RetryThrottler {\n  constructor(maxTokens, tokenRatio, previousRetryThrottler) {\n    this.maxTokens = maxTokens;\n    this.tokenRatio = tokenRatio;\n    if (previousRetryThrottler) {\n      /* When carrying over tokens from a previous config, rescale them to the\n       * new max value */\n      this.tokens = previousRetryThrottler.tokens * (maxTokens / previousRetryThrottler.maxTokens);\n    } else {\n      this.tokens = maxTokens;\n    }\n  }\n  addCallSucceeded() {\n    this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);\n  }\n  addCallFailed() {\n    this.tokens = Math.min(this.tokens - 1, 0);\n  }\n  canRetryCall() {\n    return this.tokens > this.maxTokens / 2;\n  }\n}\nexports.RetryThrottler = RetryThrottler;\nclass MessageBufferTracker {\n  constructor(totalLimit, limitPerCall) {\n    this.totalLimit = totalLimit;\n    this.limitPerCall = limitPerCall;\n    this.totalAllocated = 0;\n    this.allocatedPerCall = new Map();\n  }\n  allocate(size, callId) {\n    var _a;\n    const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n    if (this.limitPerCall - currentPerCall < size || this.totalLimit - this.totalAllocated < size) {\n      return false;\n    }\n    this.allocatedPerCall.set(callId, currentPerCall + size);\n    this.totalAllocated += size;\n    return true;\n  }\n  free(size, callId) {\n    var _a;\n    if (this.totalAllocated < size) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);\n    }\n    this.totalAllocated -= size;\n    const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n    if (currentPerCall < size) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);\n    }\n    this.allocatedPerCall.set(callId, currentPerCall - size);\n  }\n  freeAll(callId) {\n    var _a;\n    const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n    if (this.totalAllocated < currentPerCall) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);\n    }\n    this.totalAllocated -= currentPerCall;\n    this.allocatedPerCall.delete(callId);\n  }\n}\nexports.MessageBufferTracker = MessageBufferTracker;\nconst PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';\nclass RetryingCall {\n  constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler) {\n    this.channel = channel;\n    this.callConfig = callConfig;\n    this.methodName = methodName;\n    this.host = host;\n    this.credentials = credentials;\n    this.deadline = deadline;\n    this.callNumber = callNumber;\n    this.bufferTracker = bufferTracker;\n    this.retryThrottler = retryThrottler;\n    this.listener = null;\n    this.initialMetadata = null;\n    this.underlyingCalls = [];\n    this.writeBuffer = [];\n    /**\n     * Tracks whether a read has been started, so that we know whether to start\n     * reads on new child calls. This only matters for the first read, because\n     * once a message comes in the child call becomes committed and there will\n     * be no new child calls.\n     */\n    this.readStarted = false;\n    this.transparentRetryUsed = false;\n    /**\n     * Number of attempts so far\n     */\n    this.attempts = 0;\n    this.hedgingTimer = null;\n    this.committedCallIndex = null;\n    this.initialRetryBackoffSec = 0;\n    this.nextRetryBackoffSec = 0;\n    if (callConfig.methodConfig.retryPolicy) {\n      this.state = 'RETRY';\n      const retryPolicy = callConfig.methodConfig.retryPolicy;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));\n    } else if (callConfig.methodConfig.hedgingPolicy) {\n      this.state = 'HEDGING';\n    } else {\n      this.state = 'TRANSPARENT_ONLY';\n    }\n  }\n  getCallNumber() {\n    return this.callNumber;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n  }\n  reportStatus(statusObject) {\n    this.trace('ended with status: code=' + statusObject.code + ' details=\"' + statusObject.details + '\"');\n    process.nextTick(() => {\n      var _a;\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(statusObject);\n    });\n  }\n  cancelWithStatus(status, details) {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.reportStatus({\n      code: status,\n      details,\n      metadata: new metadata_1.Metadata()\n    });\n    for (const {\n      call\n    } of this.underlyingCalls) {\n      call.cancelWithStatus(status, details);\n    }\n  }\n  getPeer() {\n    if (this.committedCallIndex !== null) {\n      return this.underlyingCalls[this.committedCallIndex].call.getPeer();\n    } else {\n      return 'unknown';\n    }\n  }\n  maybefreeMessageBufferEntry(messageIndex) {\n    if (this.state !== 'COMMITTED') {\n      return;\n    }\n    const bufferEntry = this.writeBuffer[messageIndex];\n    if (bufferEntry.entryType === 'MESSAGE') {\n      if (bufferEntry.allocated) {\n        this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);\n      }\n      this.writeBuffer[messageIndex] = {\n        entryType: 'FREED',\n        allocated: false\n      };\n    }\n  }\n  commitCall(index) {\n    if (this.state === 'COMMITTED') {\n      return;\n    }\n    if (this.underlyingCalls[index].state === 'COMPLETED') {\n      return;\n    }\n    this.trace('Committing call [' + this.underlyingCalls[index].call.getCallNumber() + '] at index ' + index);\n    this.state = 'COMMITTED';\n    this.committedCallIndex = index;\n    for (let i = 0; i < this.underlyingCalls.length; i++) {\n      if (i === index) {\n        continue;\n      }\n      if (this.underlyingCalls[i].state === 'COMPLETED') {\n        continue;\n      }\n      this.underlyingCalls[i].state = 'COMPLETED';\n      this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, 'Discarded in favor of other hedged attempt');\n    }\n    for (let messageIndex = 0; messageIndex < this.underlyingCalls[index].nextMessageToSend - 1; messageIndex += 1) {\n      this.maybefreeMessageBufferEntry(messageIndex);\n    }\n  }\n  commitCallWithMostMessages() {\n    let mostMessages = -1;\n    let callWithMostMessages = -1;\n    for (const [index, childCall] of this.underlyingCalls.entries()) {\n      if (childCall.nextMessageToSend > mostMessages) {\n        mostMessages = childCall.nextMessageToSend;\n        callWithMostMessages = index;\n      }\n    }\n    this.commitCall(callWithMostMessages);\n  }\n  isStatusCodeInList(list, code) {\n    return list.some(value => value === code || value.toString().toLowerCase() === constants_1.Status[code].toLowerCase());\n  }\n  getNextRetryBackoffMs() {\n    var _a;\n    const retryPolicy = (_a = this.callConfig) === null || _a === void 0 ? void 0 : _a.methodConfig.retryPolicy;\n    if (!retryPolicy) {\n      return 0;\n    }\n    const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;\n    const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));\n    this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);\n    return nextBackoffMs;\n  }\n  maybeRetryCall(pushback, callback) {\n    if (this.state !== 'RETRY') {\n      callback(false);\n      return;\n    }\n    const retryPolicy = this.callConfig.methodConfig.retryPolicy;\n    if (this.attempts >= Math.min(retryPolicy.maxAttempts, 5)) {\n      callback(false);\n      return;\n    }\n    let retryDelayMs;\n    if (pushback === null) {\n      retryDelayMs = this.getNextRetryBackoffMs();\n    } else if (pushback < 0) {\n      this.state = 'TRANSPARENT_ONLY';\n      callback(false);\n      return;\n    } else {\n      retryDelayMs = pushback;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec;\n    }\n    setTimeout(() => {\n      var _a, _b;\n      if (this.state !== 'RETRY') {\n        callback(false);\n        return;\n      }\n      if ((_b = (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.canRetryCall()) !== null && _b !== void 0 ? _b : true) {\n        callback(true);\n        this.attempts += 1;\n        this.startNewAttempt();\n      }\n    }, retryDelayMs);\n  }\n  countActiveCalls() {\n    let count = 0;\n    for (const call of this.underlyingCalls) {\n      if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE') {\n        count += 1;\n      }\n    }\n    return count;\n  }\n  handleProcessedStatus(status, callIndex, pushback) {\n    var _a, _b, _c;\n    switch (this.state) {\n      case 'COMMITTED':\n      case 'TRANSPARENT_ONLY':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'HEDGING':\n        if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== void 0 ? _a : [], status.code)) {\n          (_b = this.retryThrottler) === null || _b === void 0 ? void 0 : _b.addCallFailed();\n          let delayMs;\n          if (pushback === null) {\n            delayMs = 0;\n          } else if (pushback < 0) {\n            this.state = 'TRANSPARENT_ONLY';\n            this.commitCall(callIndex);\n            this.reportStatus(status);\n            return;\n          } else {\n            delayMs = pushback;\n          }\n          setTimeout(() => {\n            this.maybeStartHedgingAttempt();\n            // If after trying to start a call there are no active calls, this was the last one\n            if (this.countActiveCalls() === 0) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          }, delayMs);\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n      case 'RETRY':\n        if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {\n          (_c = this.retryThrottler) === null || _c === void 0 ? void 0 : _c.addCallFailed();\n          this.maybeRetryCall(pushback, retried => {\n            if (!retried) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          });\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n    }\n  }\n  getPushback(metadata) {\n    const mdValue = metadata.get('grpc-retry-pushback-ms');\n    if (mdValue.length === 0) {\n      return null;\n    }\n    try {\n      return parseInt(mdValue[0]);\n    } catch (e) {\n      return -1;\n    }\n  }\n  handleChildStatus(status, callIndex) {\n    var _a;\n    if (this.underlyingCalls[callIndex].state === 'COMPLETED') {\n      return;\n    }\n    this.trace('state=' + this.state + ' handling status with progress ' + status.progress + ' from child [' + this.underlyingCalls[callIndex].call.getCallNumber() + '] in state ' + this.underlyingCalls[callIndex].state);\n    this.underlyingCalls[callIndex].state = 'COMPLETED';\n    if (status.code === constants_1.Status.OK) {\n      (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.addCallSucceeded();\n      this.commitCall(callIndex);\n      this.reportStatus(status);\n      return;\n    }\n    if (this.state === 'COMMITTED') {\n      this.reportStatus(status);\n      return;\n    }\n    const pushback = this.getPushback(status.metadata);\n    switch (status.progress) {\n      case 'NOT_STARTED':\n        // RPC never leaves the client, always safe to retry\n        this.startNewAttempt();\n        break;\n      case 'REFUSED':\n        // RPC reaches the server library, but not the server application logic\n        if (this.transparentRetryUsed) {\n          this.handleProcessedStatus(status, callIndex, pushback);\n        } else {\n          this.transparentRetryUsed = true;\n          this.startNewAttempt();\n        }\n        ;\n        break;\n      case 'DROP':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'PROCESSED':\n        this.handleProcessedStatus(status, callIndex, pushback);\n        break;\n    }\n  }\n  maybeStartHedgingAttempt() {\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n    if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n      return;\n    }\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n  maybeStartHedgingTimer() {\n    var _a, _b, _c;\n    if (this.hedgingTimer) {\n      clearTimeout(this.hedgingTimer);\n    }\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n    if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n      return;\n    }\n    const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== void 0 ? _a : '0s';\n    const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));\n    this.hedgingTimer = setTimeout(() => {\n      this.maybeStartHedgingAttempt();\n    }, hedgingDelaySec * 1000);\n    (_c = (_b = this.hedgingTimer).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n  }\n  startNewAttempt() {\n    const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);\n    this.trace('Created child call [' + child.getCallNumber() + '] for attempt ' + this.attempts);\n    const index = this.underlyingCalls.length;\n    this.underlyingCalls.push({\n      state: 'ACTIVE',\n      call: child,\n      nextMessageToSend: 0\n    });\n    const previousAttempts = this.attempts - 1;\n    const initialMetadata = this.initialMetadata.clone();\n    if (previousAttempts > 0) {\n      initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n    }\n    let receivedMetadata = false;\n    child.start(initialMetadata, {\n      onReceiveMetadata: metadata => {\n        this.trace('Received metadata from child [' + child.getCallNumber() + ']');\n        this.commitCall(index);\n        receivedMetadata = true;\n        if (previousAttempts > 0) {\n          metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener.onReceiveMetadata(metadata);\n        }\n      },\n      onReceiveMessage: message => {\n        this.trace('Received message from child [' + child.getCallNumber() + ']');\n        this.commitCall(index);\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener.onReceiveMessage(message);\n        }\n      },\n      onReceiveStatus: status => {\n        this.trace('Received status from child [' + child.getCallNumber() + ']');\n        if (!receivedMetadata && previousAttempts > 0) {\n          status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        this.handleChildStatus(status, index);\n      }\n    });\n    this.sendNextChildMessage(index);\n    if (this.readStarted) {\n      child.startRead();\n    }\n  }\n  start(metadata, listener) {\n    this.trace('start called');\n    this.listener = listener;\n    this.initialMetadata = metadata;\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n  handleChildWriteCompleted(childIndex) {\n    var _a, _b;\n    const childCall = this.underlyingCalls[childIndex];\n    const messageIndex = childCall.nextMessageToSend;\n    (_b = (_a = this.writeBuffer[messageIndex]).callback) === null || _b === void 0 ? void 0 : _b.call(_a);\n    this.maybefreeMessageBufferEntry(messageIndex);\n    childCall.nextMessageToSend += 1;\n    this.sendNextChildMessage(childIndex);\n  }\n  sendNextChildMessage(childIndex) {\n    const childCall = this.underlyingCalls[childIndex];\n    if (childCall.state === 'COMPLETED') {\n      return;\n    }\n    if (this.writeBuffer[childCall.nextMessageToSend]) {\n      const bufferEntry = this.writeBuffer[childCall.nextMessageToSend];\n      switch (bufferEntry.entryType) {\n        case 'MESSAGE':\n          childCall.call.sendMessageWithContext({\n            callback: error => {\n              // Ignore error\n              this.handleChildWriteCompleted(childIndex);\n            }\n          }, bufferEntry.message.message);\n          break;\n        case 'HALF_CLOSE':\n          childCall.nextMessageToSend += 1;\n          childCall.call.halfClose();\n          break;\n        case 'FREED':\n          // Should not be possible\n          break;\n      }\n    }\n  }\n  sendMessageWithContext(context, message) {\n    var _a;\n    this.trace('write() called with message of length ' + message.length);\n    const writeObj = {\n      message,\n      flags: context.flags\n    };\n    const messageIndex = this.writeBuffer.length;\n    const bufferEntry = {\n      entryType: 'MESSAGE',\n      message: writeObj,\n      allocated: this.bufferTracker.allocate(message.length, this.callNumber)\n    };\n    this.writeBuffer[messageIndex] = bufferEntry;\n    if (bufferEntry.allocated) {\n      (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n      for (const [callIndex, call] of this.underlyingCalls.entries()) {\n        if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n          call.call.sendMessageWithContext({\n            callback: error => {\n              // Ignore error\n              this.handleChildWriteCompleted(callIndex);\n            }\n          }, message);\n        }\n      }\n    } else {\n      this.commitCallWithMostMessages();\n      const call = this.underlyingCalls[this.committedCallIndex];\n      bufferEntry.callback = context.callback;\n      if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n        call.call.sendMessageWithContext({\n          callback: error => {\n            // Ignore error\n            this.handleChildWriteCompleted(this.committedCallIndex);\n          }\n        }, message);\n      }\n    }\n  }\n  startRead() {\n    this.trace('startRead called');\n    this.readStarted = true;\n    for (const underlyingCall of this.underlyingCalls) {\n      if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === 'ACTIVE') {\n        underlyingCall.call.startRead();\n      }\n    }\n  }\n  halfClose() {\n    this.trace('halfClose called');\n    const halfCloseIndex = this.writeBuffer.length;\n    this.writeBuffer[halfCloseIndex] = {\n      entryType: 'HALF_CLOSE',\n      allocated: false\n    };\n    for (const call of this.underlyingCalls) {\n      if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE' && call.nextMessageToSend === halfCloseIndex) {\n        call.nextMessageToSend += 1;\n        call.call.halfClose();\n      }\n    }\n  }\n  setCredentials(newCredentials) {\n    throw new Error(\"Method not implemented.\");\n  }\n  getMethod() {\n    return this.methodName;\n  }\n  getHost() {\n    return this.host;\n  }\n}\nexports.RetryingCall = RetryingCall;","map":{"version":3,"mappings":"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","names":["TRACER_NAME","RetryThrottler","constructor","maxTokens","tokenRatio","previousRetryThrottler","tokens","addCallSucceeded","Math","max","addCallFailed","min","canRetryCall","exports","MessageBufferTracker","totalLimit","limitPerCall","Map","allocate","size","callId","currentPerCall","allocatedPerCall","get","totalAllocated","set","free","Error","freeAll","delete","PREVIONS_RPC_ATTEMPTS_METADATA_KEY","RetryingCall","channel","callConfig","methodName","host","credentials","deadline","callNumber","bufferTracker","retryThrottler","methodConfig","retryPolicy","state","nextRetryBackoffSec","initialRetryBackoffSec","Number","initialBackoff","substring","length","hedgingPolicy","getCallNumber","trace","text","logging","constants_1","DEBUG","reportStatus","statusObject","code","details","process","nextTick","listener","onReceiveStatus","cancelWithStatus","status","metadata","metadata_1","call","underlyingCalls","getPeer","committedCallIndex","maybefreeMessageBufferEntry","messageIndex","bufferEntry","writeBuffer","entryType","allocated","message","commitCall","index","i","CANCELLED","nextMessageToSend","commitCallWithMostMessages","mostMessages","callWithMostMessages","childCall","entries","isStatusCodeInList","list","some","value","toString","toLowerCase","getNextRetryBackoffMs","nextBackoffMs","random","maxBackoffSec","maxBackoff","backoffMultiplier","maybeRetryCall","pushback","callback","attempts","maxAttempts","retryDelayMs","setTimeout","startNewAttempt","countActiveCalls","count","handleProcessedStatus","callIndex","nonFatalStatusCodes","delayMs","maybeStartHedgingAttempt","retryableStatusCodes","retried","getPushback","mdValue","parseInt","e","handleChildStatus","progress","OK","transparentRetryUsed","maybeStartHedgingTimer","hedgingTimer","clearTimeout","hedgingDelayString","hedgingDelay","hedgingDelaySec","unref","child","createLoadBalancingCall","push","previousAttempts","initialMetadata","clone","receivedMetadata","start","onReceiveMetadata","onReceiveMessage","sendNextChildMessage","readStarted","startRead","handleChildWriteCompleted","childIndex","sendMessageWithContext","error","halfClose","context","writeObj","flags","underlyingCall","halfCloseIndex","setCredentials","newCredentials","getMethod","getHost"],"sources":["E:\\React\\face-app\\node_modules\\@grpc\\grpc-js\\src\\retrying-call.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { CallCredentials } from \"./call-credentials\";\nimport { LogVerbosity, Status } from \"./constants\";\nimport { Deadline } from \"./deadline\";\nimport { Metadata } from \"./metadata\";\nimport { CallConfig } from \"./resolver\";\nimport * as logging from './logging';\nimport { Call, InterceptingListener, MessageContext, StatusObject, WriteCallback, WriteObject } from \"./call-interface\";\nimport { LoadBalancingCall, StatusObjectWithProgress } from \"./load-balancing-call\";\nimport { InternalChannel } from \"./internal-channel\";\n\nconst TRACER_NAME = 'retrying_call';\n\nexport class RetryThrottler {\n  private tokens: number;\n  constructor(private readonly maxTokens: number, private readonly tokenRatio: number, previousRetryThrottler?: RetryThrottler) {\n    if (previousRetryThrottler) {\n      /* When carrying over tokens from a previous config, rescale them to the\n       * new max value */\n      this.tokens = previousRetryThrottler.tokens * (maxTokens / previousRetryThrottler.maxTokens);\n    } else {\n      this.tokens = maxTokens;\n    }\n  }\n\n  addCallSucceeded() {\n    this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);\n  }\n\n  addCallFailed() {\n    this.tokens = Math.min(this.tokens - 1, 0);\n  }\n\n  canRetryCall() {\n    return this.tokens > this.maxTokens / 2;\n  }\n}\n\nexport class MessageBufferTracker {\n  private totalAllocated: number = 0;\n  private allocatedPerCall: Map<number, number> = new Map<number, number>();\n\n  constructor(private totalLimit: number, private limitPerCall: number) {}\n\n  allocate(size: number, callId: number): boolean {\n    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;\n    if (this.limitPerCall - currentPerCall < size || this.totalLimit - this.totalAllocated < size) {\n      return false;\n    }\n    this.allocatedPerCall.set(callId, currentPerCall + size);\n    this.totalAllocated += size;\n    return true;\n  }\n\n  free(size: number, callId: number) {\n    if (this.totalAllocated < size) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);\n    }\n    this.totalAllocated -= size;\n    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;\n    if (currentPerCall < size) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);\n    }\n    this.allocatedPerCall.set(callId, currentPerCall - size);\n  }\n\n  freeAll(callId: number) {\n    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;\n    if (this.totalAllocated < currentPerCall) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);\n    }\n    this.totalAllocated -= currentPerCall;\n    this.allocatedPerCall.delete(callId);\n  }\n}\n\ntype UnderlyingCallState = 'ACTIVE' | 'COMPLETED';\n\ninterface UnderlyingCall {\n  state: UnderlyingCallState;\n  call: LoadBalancingCall;\n  nextMessageToSend: number;\n}\n\n/**\n * A retrying call can be in one of these states:\n * RETRY: Retries are configured and new attempts may be sent\n * HEDGING: Hedging is configured and new attempts may be sent\n * TRANSPARENT_ONLY: Neither retries nor hedging are configured, and\n * transparent retry attempts may still be sent\n * COMMITTED: One attempt is committed, and no new attempts will be\n * sent\n */\ntype RetryingCallState = 'RETRY' | 'HEDGING' | 'TRANSPARENT_ONLY' | 'COMMITTED';\n\n/**\n * The different types of objects that can be stored in the write buffer, with\n * the following meanings:\n * MESSAGE: This is a message to be sent.\n * HALF_CLOSE: When this entry is reached, the calls should send a half-close.\n * FREED: This slot previously contained a message that has been sent on all\n * child calls and is no longer needed.\n */\ntype WriteBufferEntryType = 'MESSAGE' | 'HALF_CLOSE' | 'FREED';\n\n/**\n * Entry in the buffer of messages to send to the remote end.\n */\ninterface WriteBufferEntry {\n  entryType: WriteBufferEntryType;\n  /**\n   * Message to send.\n   * Only populated if entryType is MESSAGE.\n   */\n  message?: WriteObject;\n  /**\n   * Callback to call after sending the message.\n   * Only populated if entryType is MESSAGE and the call is in the COMMITTED\n   * state.\n   */\n  callback?: WriteCallback;\n  /**\n   * Indicates whether the message is allocated in the buffer tracker. Ignored\n   * if entryType is not MESSAGE. Should be the return value of\n   * bufferTracker.allocate.\n   */\n  allocated: boolean;\n}\n\nconst PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';\n\nexport class RetryingCall implements Call {\n  private state: RetryingCallState;\n  private listener: InterceptingListener | null = null;\n  private initialMetadata: Metadata | null = null;\n  private underlyingCalls: UnderlyingCall[] = [];\n  private writeBuffer: WriteBufferEntry[] = [];\n  /**\n   * Tracks whether a read has been started, so that we know whether to start\n   * reads on new child calls. This only matters for the first read, because\n   * once a message comes in the child call becomes committed and there will\n   * be no new child calls.\n   */\n  private readStarted = false;\n  private transparentRetryUsed: boolean = false;\n  /**\n   * Number of attempts so far\n   */\n  private attempts: number = 0;\n  private hedgingTimer: NodeJS.Timer | null = null;\n  private committedCallIndex: number | null = null;\n  private initialRetryBackoffSec = 0;\n  private nextRetryBackoffSec = 0;\n  constructor(\n    private readonly channel: InternalChannel,\n    private readonly callConfig: CallConfig,\n    private readonly methodName: string,\n    private readonly host: string,\n    private readonly credentials: CallCredentials,\n    private readonly deadline: Deadline,\n    private readonly callNumber: number,\n    private readonly bufferTracker: MessageBufferTracker,\n    private readonly retryThrottler?: RetryThrottler\n  ) {\n    if (callConfig.methodConfig.retryPolicy) {\n      this.state = 'RETRY';\n      const retryPolicy = callConfig.methodConfig.retryPolicy;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));\n    } else if (callConfig.methodConfig.hedgingPolicy) {\n      this.state = 'HEDGING';\n    } else {\n      this.state = 'TRANSPARENT_ONLY';\n    }\n  }\n  getCallNumber(): number {\n    return this.callNumber;\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callNumber + '] ' + text\n    );\n  }\n\n  private reportStatus(statusObject: StatusObject) {\n    this.trace('ended with status: code=' + statusObject.code + ' details=\"' + statusObject.details + '\"');\n    process.nextTick(() => {\n      this.listener?.onReceiveStatus(statusObject);\n    });\n  }\n\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.reportStatus({code: status, details, metadata: new Metadata()});\n    for (const {call} of this.underlyingCalls) {\n      call.cancelWithStatus(status, details);\n    }\n  }\n  getPeer(): string {\n    if (this.committedCallIndex !== null) {\n      return this.underlyingCalls[this.committedCallIndex].call.getPeer();\n    } else {\n      return 'unknown';\n    }\n  }\n\n  private maybefreeMessageBufferEntry(messageIndex: number) {\n    if (this.state !== 'COMMITTED') {\n      return;\n    }\n    const bufferEntry = this.writeBuffer[messageIndex];\n    if (bufferEntry.entryType === 'MESSAGE') {\n      if (bufferEntry.allocated) {\n        this.bufferTracker.free(bufferEntry.message!.message.length, this.callNumber);\n      }\n      this.writeBuffer[messageIndex] = {\n        entryType: 'FREED',\n        allocated: false\n      };\n    }\n  }\n\n  private commitCall(index: number) {\n    if (this.state === 'COMMITTED') {\n      return;\n    }\n    if (this.underlyingCalls[index].state === 'COMPLETED') {\n      return;\n    }\n    this.trace('Committing call [' + this.underlyingCalls[index].call.getCallNumber() + '] at index ' + index);\n    this.state = 'COMMITTED';\n    this.committedCallIndex = index;\n    for (let i = 0; i < this.underlyingCalls.length; i++) {\n      if (i === index) {\n        continue;\n      }\n      if (this.underlyingCalls[i].state === 'COMPLETED') {\n        continue;\n      }\n      this.underlyingCalls[i].state = 'COMPLETED';\n      this.underlyingCalls[i].call.cancelWithStatus(Status.CANCELLED, 'Discarded in favor of other hedged attempt');\n    }\n    for (let messageIndex = 0; messageIndex < this.underlyingCalls[index].nextMessageToSend - 1; messageIndex += 1) {\n      this.maybefreeMessageBufferEntry(messageIndex);\n    }\n  }\n\n  private commitCallWithMostMessages() {\n    let mostMessages = -1;\n    let callWithMostMessages = -1;\n    for (const [index, childCall] of this.underlyingCalls.entries()) {\n      if (childCall.nextMessageToSend > mostMessages) {\n        mostMessages = childCall.nextMessageToSend;\n        callWithMostMessages = index;\n      }\n    }\n    this.commitCall(callWithMostMessages);\n  }\n\n  private isStatusCodeInList(list: (Status | string)[], code: Status) {\n    return list.some((value => value === code || value.toString().toLowerCase() === Status[code].toLowerCase()));\n  }\n\n  private getNextRetryBackoffMs() {\n    const retryPolicy = this.callConfig?.methodConfig.retryPolicy;\n    if (!retryPolicy) {\n      return 0;\n    }\n    const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;\n    const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));\n    this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);\n    return nextBackoffMs\n  }\n\n  private maybeRetryCall(pushback: number | null, callback: (retried: boolean) => void) {\n    if (this.state !== 'RETRY') {\n      callback(false);\n      return;\n    }\n    const retryPolicy = this.callConfig!.methodConfig.retryPolicy!;\n    if (this.attempts >= Math.min(retryPolicy.maxAttempts, 5)) {\n      callback(false);\n      return;\n    }\n    let retryDelayMs: number;\n    if (pushback === null) {\n      retryDelayMs = this.getNextRetryBackoffMs();\n    } else if (pushback < 0) {\n      this.state = 'TRANSPARENT_ONLY';\n      callback(false);\n      return;\n    } else {\n      retryDelayMs = pushback;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec;\n    }\n    setTimeout(() => {\n      if (this.state !== 'RETRY') {\n        callback(false);\n        return;\n      }\n      if (this.retryThrottler?.canRetryCall() ?? true) {\n        callback(true);\n        this.attempts += 1;\n        this.startNewAttempt();\n      }\n    }, retryDelayMs);\n  }\n\n  private countActiveCalls(): number {\n    let count = 0;\n    for (const call of this.underlyingCalls) {\n      if (call?.state === 'ACTIVE') {\n        count += 1;\n      }\n    }\n    return count;\n  }\n\n  private handleProcessedStatus(status: StatusObject, callIndex: number, pushback: number | null) {\n    switch (this.state) {\n      case 'COMMITTED':\n      case 'TRANSPARENT_ONLY':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'HEDGING':\n        if (this.isStatusCodeInList(this.callConfig!.methodConfig.hedgingPolicy!.nonFatalStatusCodes ?? [], status.code)) {\n          this.retryThrottler?.addCallFailed();\n          let delayMs: number;\n          if (pushback === null) {\n            delayMs = 0;\n          } else if (pushback < 0) {\n            this.state = 'TRANSPARENT_ONLY';\n            this.commitCall(callIndex);\n            this.reportStatus(status);\n            return;\n          } else {\n            delayMs = pushback;\n          }\n          setTimeout(() => {\n            this.maybeStartHedgingAttempt();\n            // If after trying to start a call there are no active calls, this was the last one\n            if (this.countActiveCalls() === 0) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          }, delayMs);\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n      case 'RETRY':\n        if (this.isStatusCodeInList(this.callConfig!.methodConfig.retryPolicy!.retryableStatusCodes, status.code)) {\n          this.retryThrottler?.addCallFailed();\n          this.maybeRetryCall(pushback, (retried) => {\n            if (!retried) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          });\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n    }\n  }\n\n  private getPushback(metadata: Metadata): number | null {\n    const mdValue = metadata.get('grpc-retry-pushback-ms');\n    if (mdValue.length === 0) {\n      return null;\n    }\n    try {\n      return parseInt(mdValue[0] as string);\n    } catch (e) {\n      return -1;\n    }\n  }\n\n  private handleChildStatus(status: StatusObjectWithProgress, callIndex: number) {\n    if (this.underlyingCalls[callIndex].state === 'COMPLETED') {\n      return;\n    }\n    this.trace('state=' + this.state + ' handling status with progress ' + status.progress + ' from child [' + this.underlyingCalls[callIndex].call.getCallNumber() + '] in state ' + this.underlyingCalls[callIndex].state);\n    this.underlyingCalls[callIndex].state = 'COMPLETED';\n    if (status.code === Status.OK) {\n      this.retryThrottler?.addCallSucceeded();\n      this.commitCall(callIndex);\n      this.reportStatus(status);\n      return;\n    }\n    if (this.state === 'COMMITTED') {\n      this.reportStatus(status);\n      return;\n    }\n    const pushback = this.getPushback(status.metadata);\n    switch (status.progress) {\n      case 'NOT_STARTED':\n        // RPC never leaves the client, always safe to retry\n        this.startNewAttempt();\n        break;\n      case 'REFUSED':\n        // RPC reaches the server library, but not the server application logic\n        if (this.transparentRetryUsed) {\n          this.handleProcessedStatus(status, callIndex, pushback);\n        } else {\n          this.transparentRetryUsed = true;\n          this.startNewAttempt();\n        };\n        break;\n      case 'DROP':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'PROCESSED':\n        this.handleProcessedStatus(status, callIndex, pushback);\n        break;\n    }\n  }\n\n  private maybeStartHedgingAttempt() {\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n    if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n      return;\n    }\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n\n  private maybeStartHedgingTimer() {\n    if (this.hedgingTimer) {\n      clearTimeout(this.hedgingTimer);\n    }\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n    if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n      return;\n    }\n    const hedgingDelayString = hedgingPolicy.hedgingDelay ?? '0s';\n    const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));\n    this.hedgingTimer = setTimeout(() => {\n      this.maybeStartHedgingAttempt();\n    }, hedgingDelaySec * 1000);\n    this.hedgingTimer.unref?.();\n  }\n\n  private startNewAttempt() {\n    const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);\n    this.trace('Created child call [' + child.getCallNumber() + '] for attempt ' + this.attempts);\n    const index = this.underlyingCalls.length;\n    this.underlyingCalls.push({state: 'ACTIVE', call: child, nextMessageToSend: 0});\n    const previousAttempts = this.attempts - 1;\n    const initialMetadata = this.initialMetadata!.clone();\n    if (previousAttempts > 0) {\n      initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n    }\n    let receivedMetadata = false;\n    child.start(initialMetadata, {\n      onReceiveMetadata: metadata => {\n        this.trace('Received metadata from child [' + child.getCallNumber() + ']');\n        this.commitCall(index);\n        receivedMetadata = true;\n        if (previousAttempts > 0) {\n          metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener!.onReceiveMetadata(metadata);\n        }\n      },\n      onReceiveMessage: message => {\n        this.trace('Received message from child [' + child.getCallNumber() + ']');\n        this.commitCall(index);\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener!.onReceiveMessage(message);\n        }\n      },\n      onReceiveStatus: status => {\n        this.trace('Received status from child [' + child.getCallNumber() + ']');\n        if (!receivedMetadata && previousAttempts > 0) {\n          status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        this.handleChildStatus(status, index);\n      }\n    });\n    this.sendNextChildMessage(index);\n    if (this.readStarted) {\n      child.startRead();\n    }\n  }\n\n  start(metadata: Metadata, listener: InterceptingListener): void {\n    this.trace('start called');\n    this.listener = listener;\n    this.initialMetadata = metadata;\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n\n  private handleChildWriteCompleted(childIndex: number) {\n    const childCall = this.underlyingCalls[childIndex];\n    const messageIndex = childCall.nextMessageToSend;\n    this.writeBuffer[messageIndex].callback?.();\n    this.maybefreeMessageBufferEntry(messageIndex);\n    childCall.nextMessageToSend += 1;\n    this.sendNextChildMessage(childIndex);\n  }\n\n  private sendNextChildMessage(childIndex: number) {\n    const childCall = this.underlyingCalls[childIndex];\n    if (childCall.state === 'COMPLETED') {\n      return;\n    }\n    if (this.writeBuffer[childCall.nextMessageToSend]) {\n      const bufferEntry = this.writeBuffer[childCall.nextMessageToSend];\n      switch (bufferEntry.entryType) {\n        case 'MESSAGE': \n          childCall.call.sendMessageWithContext({\n            callback: (error) => {\n              // Ignore error\n              this.handleChildWriteCompleted(childIndex);\n            }\n          }, bufferEntry.message!.message);\n          break;\n        case 'HALF_CLOSE':\n          childCall.nextMessageToSend += 1;\n          childCall.call.halfClose();\n          break;\n        case 'FREED':\n          // Should not be possible\n          break;\n      }\n    }\n  }\n\n  sendMessageWithContext(context: MessageContext, message: Buffer): void {\n    this.trace('write() called with message of length ' + message.length);\n    const writeObj: WriteObject = {\n      message,\n      flags: context.flags,\n    };\n    const messageIndex = this.writeBuffer.length;\n    const bufferEntry: WriteBufferEntry = {\n      entryType: 'MESSAGE',\n      message: writeObj,\n      allocated: this.bufferTracker.allocate(message.length, this.callNumber)\n    };\n    this.writeBuffer[messageIndex] = bufferEntry;\n    if (bufferEntry.allocated) {\n      context.callback?.();\n      for (const [callIndex, call] of this.underlyingCalls.entries()) {\n        if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n          call.call.sendMessageWithContext({\n            callback: (error) => {\n              // Ignore error\n              this.handleChildWriteCompleted(callIndex);\n            }\n          }, message);\n        }\n      }\n    } else {\n      this.commitCallWithMostMessages();\n      const call = this.underlyingCalls[this.committedCallIndex!];\n      bufferEntry.callback = context.callback; \n      if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n        call.call.sendMessageWithContext({\n          callback: (error) => {\n            // Ignore error\n            this.handleChildWriteCompleted(this.committedCallIndex!);\n          }\n        }, message);\n      }\n    }\n  }\n  startRead(): void {\n    this.trace('startRead called');\n    this.readStarted = true;\n    for (const underlyingCall of this.underlyingCalls) {\n      if (underlyingCall?.state === 'ACTIVE') {\n        underlyingCall.call.startRead();\n      }\n    }\n  }\n  halfClose(): void {\n    this.trace('halfClose called');\n    const halfCloseIndex = this.writeBuffer.length;\n    this.writeBuffer[halfCloseIndex] = {\n      entryType: 'HALF_CLOSE',\n      allocated: false\n    };\n    for (const call of this.underlyingCalls) {\n      if (call?.state === 'ACTIVE' && call.nextMessageToSend === halfCloseIndex) {\n        call.nextMessageToSend += 1;\n        call.call.halfClose();\n      }\n    }\n  }\n  setCredentials(newCredentials: CallCredentials): void {\n    throw new Error(\"Method not implemented.\");\n  }\n  getMethod(): string {\n    return this.methodName;\n  }\n  getHost(): string {\n    return this.host;\n  }\n}"]},"metadata":{},"sourceType":"script","externalDependencies":[]}