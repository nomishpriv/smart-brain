{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2SubchannelCall = void 0;\nconst http2 = require(\"http2\");\nconst os = require(\"os\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst stream_decoder_1 = require(\"./stream-decoder\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst TRACER_NAME = 'subchannel_call';\nconst {\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_CONTENT_TYPE,\n  NGHTTP2_CANCEL\n} = http2.constants;\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno) {\n  for (const [name, num] of Object.entries(os.constants.errno)) {\n    if (num === errno) {\n      return name;\n    }\n  }\n  return 'Unknown system error ' + errno;\n}\nclass Http2SubchannelCall {\n  constructor(http2Stream, callStatsTracker, listener, subchannel, callId) {\n    this.http2Stream = http2Stream;\n    this.callStatsTracker = callStatsTracker;\n    this.listener = listener;\n    this.subchannel = subchannel;\n    this.callId = callId;\n    this.decoder = new stream_decoder_1.StreamDecoder();\n    this.isReadFilterPending = false;\n    this.canPush = false;\n    /**\n     * Indicates that an 'end' event has come from the http2 stream, so there\n     * will be no more data events.\n     */\n    this.readsClosed = false;\n    this.statusOutput = false;\n    this.unpushedReadMessages = [];\n    // Status code mapped from :status. To be used if grpc-status is not received\n    this.mappedStatusCode = constants_1.Status.UNKNOWN;\n    // This is populated (non-null) if and only if the call has ended\n    this.finalStatus = null;\n    this.internalError = null;\n    this.disconnectListener = () => {\n      this.endCall({\n        code: constants_1.Status.UNAVAILABLE,\n        details: 'Connection dropped',\n        metadata: new metadata_1.Metadata()\n      });\n    };\n    subchannel.addDisconnectListener(this.disconnectListener);\n    subchannel.callRef();\n    http2Stream.on('response', (headers, flags) => {\n      let headersString = '';\n      for (const header of Object.keys(headers)) {\n        headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n      }\n      this.trace('Received server headers:\\n' + headersString);\n      switch (headers[':status']) {\n        // TODO(murgatroid99): handle 100 and 101\n        case 400:\n          this.mappedStatusCode = constants_1.Status.INTERNAL;\n          break;\n        case 401:\n          this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n          break;\n        case 403:\n          this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n          break;\n        case 404:\n          this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n          break;\n        case 429:\n        case 502:\n        case 503:\n        case 504:\n          this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n          break;\n        default:\n          this.mappedStatusCode = constants_1.Status.UNKNOWN;\n      }\n      if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n        this.handleTrailers(headers);\n      } else {\n        let metadata;\n        try {\n          metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        } catch (error) {\n          this.endCall({\n            code: constants_1.Status.UNKNOWN,\n            details: error.message,\n            metadata: new metadata_1.Metadata()\n          });\n          return;\n        }\n        this.listener.onReceiveMetadata(metadata);\n      }\n    });\n    http2Stream.on('trailers', headers => {\n      this.handleTrailers(headers);\n    });\n    http2Stream.on('data', data => {\n      /* If the status has already been output, allow the http2 stream to\n       * drain without processing the data. */\n      if (this.statusOutput) {\n        return;\n      }\n      this.trace('receive HTTP/2 data frame of length ' + data.length);\n      const messages = this.decoder.write(data);\n      for (const message of messages) {\n        this.trace('parsed message of length ' + message.length);\n        this.callStatsTracker.addMessageReceived();\n        this.tryPush(message);\n      }\n    });\n    http2Stream.on('end', () => {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n    });\n    http2Stream.on('close', () => {\n      /* Use process.next tick to ensure that this code happens after any\n       * \"error\" event that may be emitted at about the same time, so that\n       * we can bubble up the error message from that event. */\n      process.nextTick(() => {\n        var _a;\n        this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);\n        /* If we have a final status with an OK status code, that means that\n         * we have received all of the messages and we have processed the\n         * trailers and the call completed successfully, so it doesn't matter\n         * how the stream ends after that */\n        if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n          return;\n        }\n        let code;\n        let details = '';\n        switch (http2Stream.rstCode) {\n          case http2.constants.NGHTTP2_NO_ERROR:\n            /* If we get a NO_ERROR code and we already have a status, the\n             * stream completed properly and we just haven't fully processed\n             * it yet */\n            if (this.finalStatus !== null) {\n              return;\n            }\n            code = constants_1.Status.INTERNAL;\n            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n            break;\n          case http2.constants.NGHTTP2_REFUSED_STREAM:\n            code = constants_1.Status.UNAVAILABLE;\n            details = 'Stream refused by server';\n            break;\n          case http2.constants.NGHTTP2_CANCEL:\n            code = constants_1.Status.CANCELLED;\n            details = 'Call cancelled';\n            break;\n          case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n            code = constants_1.Status.RESOURCE_EXHAUSTED;\n            details = 'Bandwidth exhausted or memory limit exceeded';\n            break;\n          case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n            code = constants_1.Status.PERMISSION_DENIED;\n            details = 'Protocol not secure enough';\n            break;\n          case http2.constants.NGHTTP2_INTERNAL_ERROR:\n            code = constants_1.Status.INTERNAL;\n            if (this.internalError === null) {\n              /* This error code was previously handled in the default case, and\n               * there are several instances of it online, so I wanted to\n               * preserve the original error message so that people find existing\n               * information in searches, but also include the more recognizable\n               * \"Internal server error\" message. */\n              details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\n            } else {\n              if (this.internalError.code === 'ECONNRESET' || this.internalError.code === 'ETIMEDOUT') {\n                code = constants_1.Status.UNAVAILABLE;\n                details = this.internalError.message;\n              } else {\n                /* The \"Received RST_STREAM with code ...\" error is preserved\n                 * here for continuity with errors reported online, but the\n                 * error message at the end will probably be more relevant in\n                 * most cases. */\n                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n              }\n            }\n            break;\n          default:\n            code = constants_1.Status.INTERNAL;\n            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n        }\n        // This is a no-op if trailers were received at all.\n        // This is OK, because status codes emitted here correspond to more\n        // catastrophic issues that prevent us from receiving trailers in the\n        // first place.\n        this.endCall({\n          code,\n          details,\n          metadata: new metadata_1.Metadata(),\n          rstCode: http2Stream.rstCode\n        });\n      });\n    });\n    http2Stream.on('error', err => {\n      /* We need an error handler here to stop \"Uncaught Error\" exceptions\n       * from bubbling up. However, errors here should all correspond to\n       * \"close\" events, where we will handle the error more granularly */\n      /* Specifically looking for stream errors that were *not* constructed\n       * from a RST_STREAM response here:\n       * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n       */\n      if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n        this.trace('Node error event: message=' + err.message + ' code=' + err.code + ' errno=' + getSystemErrorName(err.errno) + ' syscall=' + err.syscall);\n        this.internalError = err;\n      }\n      this.callStatsTracker.onStreamEnd(false);\n    });\n  }\n  outputStatus() {\n    /* Precondition: this.finalStatus !== null */\n    if (!this.statusOutput) {\n      this.statusOutput = true;\n      this.trace('ended with status: code=' + this.finalStatus.code + ' details=\"' + this.finalStatus.details + '\"');\n      this.callStatsTracker.onCallEnd(this.finalStatus);\n      /* We delay the actual action of bubbling up the status to insulate the\n       * cleanup code in this class from any errors that may be thrown in the\n       * upper layers as a result of bubbling up the status. In particular,\n       * if the status is not OK, the \"error\" event may be emitted\n       * synchronously at the top level, which will result in a thrown error if\n       * the user does not handle that event. */\n      process.nextTick(() => {\n        this.listener.onReceiveStatus(this.finalStatus);\n      });\n      /* Leave the http2 stream in flowing state to drain incoming messages, to\n       * ensure that the stream closure completes. The call stream already does\n       * not push more messages after the status is output, so the messages go\n       * nowhere either way. */\n      this.http2Stream.resume();\n      this.subchannel.callUnref();\n      this.subchannel.removeDisconnectListener(this.disconnectListener);\n    }\n  }\n  trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callId + '] ' + text);\n  }\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n  endCall(status) {\n    /* If the status is OK and a new status comes in (e.g. from a\n     * deserialization failure), that new status takes priority */\n    if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n      this.finalStatus = status;\n      this.maybeOutputStatus();\n    }\n    this.destroyHttp2Stream();\n  }\n  maybeOutputStatus() {\n    if (this.finalStatus !== null) {\n      /* The combination check of readsClosed and that the two message buffer\n       * arrays are empty checks that there all incoming data has been fully\n       * processed */\n      if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && !this.isReadFilterPending) {\n        this.outputStatus();\n      }\n    }\n  }\n  push(message) {\n    this.trace('pushing to reader message of length ' + (message instanceof Buffer ? message.length : null));\n    this.canPush = false;\n    process.nextTick(() => {\n      /* If we have already output the status any later messages should be\n       * ignored, and can cause out-of-order operation errors higher up in the\n       * stack. Checking as late as possible here to avoid any race conditions.\n       */\n      if (this.statusOutput) {\n        return;\n      }\n      this.listener.onReceiveMessage(message);\n      this.maybeOutputStatus();\n    });\n  }\n  tryPush(messageBytes) {\n    if (this.canPush) {\n      this.http2Stream.pause();\n      this.push(messageBytes);\n    } else {\n      this.trace('unpushedReadMessages.push message of length ' + messageBytes.length);\n      this.unpushedReadMessages.push(messageBytes);\n    }\n  }\n  handleTrailers(headers) {\n    this.callStatsTracker.onStreamEnd(true);\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    this.trace('Received server trailers:\\n' + headersString);\n    let metadata;\n    try {\n      metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n    } catch (e) {\n      metadata = new metadata_1.Metadata();\n    }\n    const metadataMap = metadata.getMap();\n    let code = this.mappedStatusCode;\n    if (code === constants_1.Status.UNKNOWN && typeof metadataMap['grpc-status'] === 'string') {\n      const receivedStatus = Number(metadataMap['grpc-status']);\n      if (receivedStatus in constants_1.Status) {\n        code = receivedStatus;\n        this.trace('received status code ' + receivedStatus + ' from server');\n      }\n      metadata.remove('grpc-status');\n    }\n    let details = '';\n    if (typeof metadataMap['grpc-message'] === 'string') {\n      try {\n        details = decodeURI(metadataMap['grpc-message']);\n      } catch (e) {\n        details = metadataMap['grpc-message'];\n      }\n      metadata.remove('grpc-message');\n      this.trace('received status details string \"' + details + '\" from server');\n    }\n    const status = {\n      code,\n      details,\n      metadata\n    };\n    // This is a no-op if the call was already ended when handling headers.\n    this.endCall(status);\n  }\n  destroyHttp2Stream() {\n    var _a;\n    // The http2 stream could already have been destroyed if cancelWithStatus\n    // is called in response to an internal http2 error.\n    if (!this.http2Stream.destroyed) {\n      /* If the call has ended with an OK status, communicate that when closing\n       * the stream, partly to avoid a situation in which we detect an error\n       * RST_STREAM as a result after we have the status */\n      let code;\n      if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n        code = http2.constants.NGHTTP2_NO_ERROR;\n      } else {\n        code = http2.constants.NGHTTP2_CANCEL;\n      }\n      this.trace('close http2 stream with code ' + code);\n      this.http2Stream.close(code);\n    }\n  }\n  cancelWithStatus(status, details) {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.endCall({\n      code: status,\n      details,\n      metadata: new metadata_1.Metadata()\n    });\n  }\n  getStatus() {\n    return this.finalStatus;\n  }\n  getPeer() {\n    return this.subchannel.getAddress();\n  }\n  getCallNumber() {\n    return this.callId;\n  }\n  startRead() {\n    /* If the stream has ended with an error, we should not emit any more\n     * messages and we should communicate that the stream has ended */\n    if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n      return;\n    }\n    this.canPush = true;\n    if (this.unpushedReadMessages.length > 0) {\n      const nextMessage = this.unpushedReadMessages.shift();\n      this.push(nextMessage);\n      return;\n    }\n    /* Only resume reading from the http2Stream if we don't have any pending\n      * messages to emit */\n    this.http2Stream.resume();\n  }\n  sendMessageWithContext(context, message) {\n    this.trace('write() called with message of length ' + message.length);\n    const cb = error => {\n      var _a;\n      let code = constants_1.Status.UNAVAILABLE;\n      if ((error === null || error === void 0 ? void 0 : error.code) === 'ERR_STREAM_WRITE_AFTER_END') {\n        code = constants_1.Status.INTERNAL;\n      }\n      if (error) {\n        this.cancelWithStatus(code, `Write error: ${error.message}`);\n      }\n      (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n    };\n    this.trace('sending data chunk of length ' + message.length);\n    this.callStatsTracker.addMessageSent();\n    try {\n      this.http2Stream.write(message, cb);\n    } catch (error) {\n      this.endCall({\n        code: constants_1.Status.UNAVAILABLE,\n        details: `Write failed with error ${error.message}`,\n        metadata: new metadata_1.Metadata()\n      });\n    }\n  }\n  halfClose() {\n    this.trace('end() called');\n    this.trace('calling end() on HTTP/2 stream');\n    this.http2Stream.end();\n  }\n}\nexports.Http2SubchannelCall = Http2SubchannelCall;","map":{"version":3,"mappings":"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","names":["TRACER_NAME","HTTP2_HEADER_STATUS","HTTP2_HEADER_CONTENT_TYPE","NGHTTP2_CANCEL","http2","constants","getSystemErrorName","errno","name","num","Object","entries","os","Http2SubchannelCall","constructor","http2Stream","callStatsTracker","listener","subchannel","callId","stream_decoder_1","constants_1","UNKNOWN","disconnectListener","endCall","code","UNAVAILABLE","details","metadata","metadata_1","addDisconnectListener","callRef","on","headers","flags","headersString","header","keys","trace","mappedStatusCode","INTERNAL","UNAUTHENTICATED","PERMISSION_DENIED","UNIMPLEMENTED","NGHTTP2_FLAG_END_STREAM","handleTrailers","fromHttp2Headers","error","message","onReceiveMetadata","data","statusOutput","length","messages","decoder","write","addMessageReceived","tryPush","readsClosed","maybeOutputStatus","process","nextTick","rstCode","finalStatus","OK","NGHTTP2_NO_ERROR","NGHTTP2_REFUSED_STREAM","CANCELLED","NGHTTP2_ENHANCE_YOUR_CALM","RESOURCE_EXHAUSTED","NGHTTP2_INADEQUATE_SECURITY","NGHTTP2_INTERNAL_ERROR","internalError","err","syscall","onStreamEnd","outputStatus","onCallEnd","onReceiveStatus","resume","callUnref","removeDisconnectListener","text","logging","constants_2","DEBUG","status","destroyHttp2Stream","unpushedReadMessages","isReadFilterPending","push","Buffer","canPush","onReceiveMessage","messageBytes","pause","e","metadataMap","getMap","receivedStatus","Number","remove","decodeURI","destroyed","close","cancelWithStatus","getStatus","getPeer","getAddress","getCallNumber","startRead","nextMessage","shift","sendMessageWithContext","context","cb","callback","addMessageSent","halfClose","end","exports"],"sources":["E:\\React\\face-app\\node_modules\\@grpc\\grpc-js\\src\\subchannel-call.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport * as os from 'os';\n\nimport { Status } from './constants';\nimport { Metadata } from './metadata';\nimport { StreamDecoder } from './stream-decoder';\nimport { SubchannelCallStatsTracker, Subchannel } from './subchannel';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport { ServerSurfaceCall } from './server-call';\nimport { Deadline } from './deadline';\nimport { InterceptingListener, MessageContext, StatusObject, WriteCallback } from './call-interface';\n\nconst TRACER_NAME = 'subchannel_call';\n\nconst {\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_CONTENT_TYPE,\n  NGHTTP2_CANCEL,\n} = http2.constants;\n\n/**\n * https://nodejs.org/api/errors.html#errors_class_systemerror\n */\ninterface SystemError extends Error {\n  address?: string;\n  code: string;\n  dest?: string;\n  errno: number;\n  info?: object;\n  message: string;\n  path?: string;\n  port?: number;\n  syscall: string;\n}\n\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno: number): string {\n  for (const [name, num] of Object.entries(os.constants.errno)) {\n    if (num === errno) {\n      return name;\n    }\n  }\n  return 'Unknown system error ' + errno;\n}\n\nexport interface SubchannelCall {\n  cancelWithStatus(status: Status, details: string): void;\n  getPeer(): string;\n  sendMessageWithContext(context: MessageContext, message: Buffer): void;\n  startRead(): void;\n  halfClose(): void;\n  getCallNumber(): number;\n}\n\nexport interface StatusObjectWithRstCode extends StatusObject {\n  rstCode?: number;\n}\n\nexport interface SubchannelCallInterceptingListener extends InterceptingListener {\n  onReceiveStatus(status: StatusObjectWithRstCode): void;\n}\n\nexport class Http2SubchannelCall implements SubchannelCall {\n  private decoder = new StreamDecoder();\n\n  private isReadFilterPending = false;\n  private canPush = false;\n  /**\n   * Indicates that an 'end' event has come from the http2 stream, so there\n   * will be no more data events.\n   */\n  private readsClosed = false;\n\n  private statusOutput = false;\n\n  private unpushedReadMessages: Buffer[] = [];\n\n  // Status code mapped from :status. To be used if grpc-status is not received\n  private mappedStatusCode: Status = Status.UNKNOWN;\n\n  // This is populated (non-null) if and only if the call has ended\n  private finalStatus: StatusObject | null = null;\n\n  private disconnectListener: () => void;\n\n  private internalError: SystemError | null = null;\n\n  constructor(\n    private readonly http2Stream: http2.ClientHttp2Stream,\n    private readonly callStatsTracker: SubchannelCallStatsTracker,\n    private readonly listener: SubchannelCallInterceptingListener,\n    private readonly subchannel: Subchannel,\n    private readonly callId: number\n  ) {\n    this.disconnectListener = () => {\n      this.endCall({\n        code: Status.UNAVAILABLE,\n        details: 'Connection dropped',\n        metadata: new Metadata(),\n      });\n    };\n    subchannel.addDisconnectListener(this.disconnectListener);\n    subchannel.callRef();\n    http2Stream.on('response', (headers, flags) => {\n      let headersString = '';\n      for (const header of Object.keys(headers)) {\n        headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n      }\n      this.trace('Received server headers:\\n' + headersString);\n      switch (headers[':status']) {\n        // TODO(murgatroid99): handle 100 and 101\n        case 400:\n          this.mappedStatusCode = Status.INTERNAL;\n          break;\n        case 401:\n          this.mappedStatusCode = Status.UNAUTHENTICATED;\n          break;\n        case 403:\n          this.mappedStatusCode = Status.PERMISSION_DENIED;\n          break;\n        case 404:\n          this.mappedStatusCode = Status.UNIMPLEMENTED;\n          break;\n        case 429:\n        case 502:\n        case 503:\n        case 504:\n          this.mappedStatusCode = Status.UNAVAILABLE;\n          break;\n        default:\n          this.mappedStatusCode = Status.UNKNOWN;\n      }\n\n      if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n        this.handleTrailers(headers);\n      } else {\n        let metadata: Metadata;\n        try {\n          metadata = Metadata.fromHttp2Headers(headers);\n        } catch (error) {\n          this.endCall({\n            code: Status.UNKNOWN,\n            details: (error as Error).message,\n            metadata: new Metadata(),\n          });\n          return;\n        }\n        this.listener.onReceiveMetadata(metadata);\n      }\n    });\n    http2Stream.on('trailers', (headers: http2.IncomingHttpHeaders) => {\n      this.handleTrailers(headers);\n    });\n    http2Stream.on('data', (data: Buffer) => {\n      /* If the status has already been output, allow the http2 stream to\n       * drain without processing the data. */\n      if (this.statusOutput) {\n        return;\n      }\n      this.trace('receive HTTP/2 data frame of length ' + data.length);\n      const messages = this.decoder.write(data);\n\n      for (const message of messages) {\n        this.trace('parsed message of length ' + message.length);\n        this.callStatsTracker!.addMessageReceived();\n        this.tryPush(message);\n      }\n    });\n    http2Stream.on('end', () => {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n    });\n    http2Stream.on('close', () => {\n      /* Use process.next tick to ensure that this code happens after any\n       * \"error\" event that may be emitted at about the same time, so that\n       * we can bubble up the error message from that event. */\n      process.nextTick(() => {\n        this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);\n        /* If we have a final status with an OK status code, that means that\n         * we have received all of the messages and we have processed the\n         * trailers and the call completed successfully, so it doesn't matter\n         * how the stream ends after that */\n        if (this.finalStatus?.code === Status.OK) {\n          return;\n        }\n        let code: Status;\n        let details = '';\n        switch (http2Stream.rstCode) {\n          case http2.constants.NGHTTP2_NO_ERROR:\n            /* If we get a NO_ERROR code and we already have a status, the\n             * stream completed properly and we just haven't fully processed\n             * it yet */\n            if (this.finalStatus !== null) {\n              return;\n            }\n            code = Status.INTERNAL;\n            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n            break;\n          case http2.constants.NGHTTP2_REFUSED_STREAM:\n            code = Status.UNAVAILABLE;\n            details = 'Stream refused by server';\n            break;\n          case http2.constants.NGHTTP2_CANCEL:\n            code = Status.CANCELLED;\n            details = 'Call cancelled';\n            break;\n          case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n            code = Status.RESOURCE_EXHAUSTED;\n            details = 'Bandwidth exhausted or memory limit exceeded';\n            break;\n          case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n            code = Status.PERMISSION_DENIED;\n            details = 'Protocol not secure enough';\n            break;\n          case http2.constants.NGHTTP2_INTERNAL_ERROR:\n            code = Status.INTERNAL;\n            if (this.internalError === null) {\n              /* This error code was previously handled in the default case, and\n               * there are several instances of it online, so I wanted to\n               * preserve the original error message so that people find existing\n               * information in searches, but also include the more recognizable\n               * \"Internal server error\" message. */\n              details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\n            } else {\n              if (this.internalError.code === 'ECONNRESET' || this.internalError.code === 'ETIMEDOUT') {\n                code = Status.UNAVAILABLE;\n                details = this.internalError.message;\n              } else {\n                /* The \"Received RST_STREAM with code ...\" error is preserved\n                 * here for continuity with errors reported online, but the\n                 * error message at the end will probably be more relevant in\n                 * most cases. */\n                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n              }\n            }\n            break;\n          default:\n            code = Status.INTERNAL;\n            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n        }\n        // This is a no-op if trailers were received at all.\n        // This is OK, because status codes emitted here correspond to more\n        // catastrophic issues that prevent us from receiving trailers in the\n        // first place.\n        this.endCall({ code, details, metadata: new Metadata(), rstCode: http2Stream.rstCode });\n      });\n    });\n    http2Stream.on('error', (err: SystemError) => {\n      /* We need an error handler here to stop \"Uncaught Error\" exceptions\n       * from bubbling up. However, errors here should all correspond to\n       * \"close\" events, where we will handle the error more granularly */\n      /* Specifically looking for stream errors that were *not* constructed\n       * from a RST_STREAM response here:\n       * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n       */\n      if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n        this.trace(\n          'Node error event: message=' +\n            err.message +\n            ' code=' +\n            err.code +\n            ' errno=' +\n            getSystemErrorName(err.errno) +\n            ' syscall=' +\n            err.syscall\n        );\n        this.internalError = err;\n      }\n      this.callStatsTracker.onStreamEnd(false);\n    });\n  }\n\n  private outputStatus() {\n    /* Precondition: this.finalStatus !== null */\n    if (!this.statusOutput) {\n      this.statusOutput = true;\n      this.trace(\n        'ended with status: code=' +\n          this.finalStatus!.code +\n          ' details=\"' +\n          this.finalStatus!.details +\n          '\"'\n      );\n      this.callStatsTracker.onCallEnd(this.finalStatus!);\n      /* We delay the actual action of bubbling up the status to insulate the\n       * cleanup code in this class from any errors that may be thrown in the\n       * upper layers as a result of bubbling up the status. In particular,\n       * if the status is not OK, the \"error\" event may be emitted\n       * synchronously at the top level, which will result in a thrown error if\n       * the user does not handle that event. */\n      process.nextTick(() => {\n        this.listener.onReceiveStatus(this.finalStatus!);\n      });\n      /* Leave the http2 stream in flowing state to drain incoming messages, to\n       * ensure that the stream closure completes. The call stream already does\n       * not push more messages after the status is output, so the messages go\n       * nowhere either way. */\n      this.http2Stream.resume();\n      this.subchannel.callUnref();\n      this.subchannel.removeDisconnectListener(this.disconnectListener);\n    }\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callId + '] ' + text\n    );\n  }\n\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n  private endCall(status: StatusObjectWithRstCode): void {\n    /* If the status is OK and a new status comes in (e.g. from a\n     * deserialization failure), that new status takes priority */\n    if (this.finalStatus === null || this.finalStatus.code === Status.OK) {\n      this.finalStatus = status;\n      this.maybeOutputStatus();\n    }\n    this.destroyHttp2Stream();\n  }\n\n  private maybeOutputStatus() {\n    if (this.finalStatus !== null) {\n      /* The combination check of readsClosed and that the two message buffer\n       * arrays are empty checks that there all incoming data has been fully\n       * processed */\n      if (\n        this.finalStatus.code !== Status.OK ||\n        (this.readsClosed &&\n          this.unpushedReadMessages.length === 0 &&\n          !this.isReadFilterPending)\n      ) {\n        this.outputStatus();\n      }\n    }\n  }\n\n  private push(message: Buffer): void {\n    this.trace(\n      'pushing to reader message of length ' +\n        (message instanceof Buffer ? message.length : null)\n    );\n    this.canPush = false;\n    process.nextTick(() => {\n      /* If we have already output the status any later messages should be\n       * ignored, and can cause out-of-order operation errors higher up in the\n       * stack. Checking as late as possible here to avoid any race conditions.\n       */\n      if (this.statusOutput) {\n        return;\n      }\n      this.listener.onReceiveMessage(message);\n      this.maybeOutputStatus();\n    });\n  }\n\n  private tryPush(messageBytes: Buffer): void {\n    if (this.canPush) {\n      this.http2Stream!.pause();\n      this.push(messageBytes);\n    } else {\n      this.trace(\n        'unpushedReadMessages.push message of length ' + messageBytes.length\n      );\n      this.unpushedReadMessages.push(messageBytes);\n    }\n  }\n\n  private handleTrailers(headers: http2.IncomingHttpHeaders) {\n    this.callStatsTracker.onStreamEnd(true);\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    this.trace('Received server trailers:\\n' + headersString);\n    let metadata: Metadata;\n    try {\n      metadata = Metadata.fromHttp2Headers(headers);\n    } catch (e) {\n      metadata = new Metadata();\n    }\n    const metadataMap = metadata.getMap();\n    let code: Status = this.mappedStatusCode;\n    if (\n      code === Status.UNKNOWN &&\n      typeof metadataMap['grpc-status'] === 'string'\n    ) {\n      const receivedStatus = Number(metadataMap['grpc-status']);\n      if (receivedStatus in Status) {\n        code = receivedStatus;\n        this.trace('received status code ' + receivedStatus + ' from server');\n      }\n      metadata.remove('grpc-status');\n    }\n    let details = '';\n    if (typeof metadataMap['grpc-message'] === 'string') {\n      try {\n        details = decodeURI(metadataMap['grpc-message']);\n      } catch (e) {\n        details = metadataMap['grpc-message'];\n      }\n      metadata.remove('grpc-message');\n      this.trace(\n        'received status details string \"' + details + '\" from server'\n      );\n    }\n    const status: StatusObject = { code, details, metadata };\n    // This is a no-op if the call was already ended when handling headers.\n    this.endCall(status);\n  }\n\n  private destroyHttp2Stream() {\n    // The http2 stream could already have been destroyed if cancelWithStatus\n    // is called in response to an internal http2 error.\n    if (!this.http2Stream.destroyed) {\n      /* If the call has ended with an OK status, communicate that when closing\n       * the stream, partly to avoid a situation in which we detect an error\n       * RST_STREAM as a result after we have the status */\n      let code: number;\n      if (this.finalStatus?.code === Status.OK) {\n        code = http2.constants.NGHTTP2_NO_ERROR;\n      } else {\n        code = http2.constants.NGHTTP2_CANCEL;\n      }\n      this.trace('close http2 stream with code ' + code);\n      this.http2Stream.close(code);\n    }\n  }\n\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace(\n      'cancelWithStatus code: ' + status + ' details: \"' + details + '\"'\n    );\n    this.endCall({ code: status, details, metadata: new Metadata() });\n  }\n\n  getStatus(): StatusObject | null {\n    return this.finalStatus;\n  }\n\n  getPeer(): string {\n    return this.subchannel.getAddress();\n  }\n\n  getCallNumber(): number {\n    return this.callId;\n  }\n\n  startRead() {\n    /* If the stream has ended with an error, we should not emit any more\n     * messages and we should communicate that the stream has ended */\n    if (this.finalStatus !== null && this.finalStatus.code !== Status.OK) {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n      return;\n    }\n    this.canPush = true;\n    if (this.unpushedReadMessages.length > 0) {\n      const nextMessage: Buffer = this.unpushedReadMessages.shift()!;\n      this.push(nextMessage);\n      return;\n    }\n    /* Only resume reading from the http2Stream if we don't have any pending\n      * messages to emit */\n    this.http2Stream.resume();\n  }\n\n  sendMessageWithContext(context: MessageContext, message: Buffer) {\n    this.trace('write() called with message of length ' + message.length);\n    const cb: WriteCallback = (error?: Error | null) => {\n      let code: Status = Status.UNAVAILABLE;\n      if ((error as NodeJS.ErrnoException)?.code === 'ERR_STREAM_WRITE_AFTER_END') {\n        code = Status.INTERNAL;\n      }\n      if (error) {\n        this.cancelWithStatus(code, `Write error: ${error.message}`);\n      }\n      context.callback?.();\n    };\n    this.trace('sending data chunk of length ' + message.length);\n    this.callStatsTracker.addMessageSent();\n    try {\n      this.http2Stream!.write(message, cb);\n    } catch (error) {\n      this.endCall({\n        code: Status.UNAVAILABLE,\n        details: `Write failed with error ${(error as Error).message}`,\n        metadata: new Metadata()\n      });\n    }\n  }\n\n  halfClose() {\n    this.trace('end() called');\n    this.trace('calling end() on HTTP/2 stream');\n    this.http2Stream.end();\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}