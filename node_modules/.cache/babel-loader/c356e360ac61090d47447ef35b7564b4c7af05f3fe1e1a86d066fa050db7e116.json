{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subchannel = void 0;\nconst http2 = require(\"http2\");\nconst tls_1 = require(\"tls\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst resolver_1 = require(\"./resolver\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst http_proxy_1 = require(\"./http_proxy\");\nconst net = require(\"net\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst channelz_1 = require(\"./channelz\");\nconst subchannel_call_1 = require(\"./subchannel-call\");\nconst call_number_1 = require(\"./call-number\");\nconst clientVersion = require('../../package.json').version;\nconst TRACER_NAME = 'subchannel';\nconst FLOW_CONTROL_TRACER_NAME = 'subchannel_flowctrl';\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT\n} = http2.constants;\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\nclass Subchannel {\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(channelTarget, subchannelAddress, options, credentials) {\n    this.channelTarget = channelTarget;\n    this.subchannelAddress = subchannelAddress;\n    this.options = options;\n    this.credentials = credentials;\n    /**\n     * The subchannel's current connectivity state. Invariant: `session` === `null`\n     * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n     */\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The underlying http2 session used to make requests.\n     */\n    this.session = null;\n    /**\n     * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n     * CONNECTING instead of IDLE when the backoff timeout ends.\n     */\n    this.continueConnecting = false;\n    /**\n     * A list of listener functions that will be called whenever the connectivity\n     * state changes. Will be modified by `addConnectivityStateListener` and\n     * `removeConnectivityStateListener`\n     */\n    this.stateListeners = [];\n    /**\n     * A list of listener functions that will be called when the underlying\n     * socket disconnects. Used for ending active calls with an UNAVAILABLE\n     * status.\n     */\n    this.disconnectListeners = new Set();\n    /**\n     * The amount of time in between sending pings\n     */\n    this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;\n    /**\n     * The amount of time to wait for an acknowledgement after sending a ping\n     */\n    this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    /**\n     * Indicates whether keepalive pings should be sent without any active calls\n     */\n    this.keepaliveWithoutCalls = false;\n    /**\n     * Tracks calls with references to this subchannel\n     */\n    this.callRefcount = 0;\n    /**\n     * Tracks channels and subchannel pools with references to this subchannel\n     */\n    this.refcount = 0;\n    // Channelz info\n    this.channelzEnabled = true;\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n    // Channelz socket info\n    this.channelzSocketRef = null;\n    /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */\n    this.remoteName = null;\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n    // Build user-agent string.\n    this.userAgent = [options['grpc.primary_user_agent'], `grpc-node-js/${clientVersion}`, options['grpc.secondary_user_agent']].filter(e => e).join(' '); // remove falsey values first\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls = options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    this.keepaliveTimeoutId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveTimeoutId);\n    const backoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n    this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    }\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n  getChannelzInfo() {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n  getChannelzSocketInfo() {\n    var _a, _b, _c;\n    if (this.session === null) {\n      return null;\n    }\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo;\n    if (this.session.encrypted) {\n      const tlsSocket = sessionSocket;\n      const cipherInfo = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n      remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n    };\n    return socketInfo;\n  }\n  resetChannelzSocketInfo() {\n    if (!this.channelzEnabled) {\n      return;\n    }\n    if (this.channelzSocketRef) {\n      (0, channelz_1.unregisterChannelzRef)(this.channelzSocketRef);\n      this.childrenTracker.unrefChild(this.channelzSocketRef);\n      this.channelzSocketRef = null;\n    }\n    this.remoteName = null;\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  refTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  flowControlTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  internalsTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  keepaliveTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n    } else {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\n    }\n  }\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n  stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n  sendPing() {\n    var _a, _b;\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n    this.keepaliveTimeoutId = setTimeout(() => {\n      this.keepaliveTrace('Ping timeout passed without response');\n      this.handleDisconnect();\n    }, this.keepaliveTimeoutMs);\n    (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    try {\n      this.session.ping((err, duration, payload) => {\n        this.keepaliveTrace('Received ping response');\n        clearTimeout(this.keepaliveTimeoutId);\n      });\n    } catch (e) {\n      /* If we fail to send a ping, the connection is no longer functional, so\n       * we should discard it. */\n      this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    }\n  }\n  startKeepalivePings() {\n    var _a, _b;\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    /* Don't send a ping immediately because whatever caused us to start\n     * sending pings should also involve some network activity. */\n  }\n  /**\n   * Stop keepalive pings when terminating a connection. This discards the\n   * outstanding ping timeout, so it should not be called if the same\n   * connection will still be used.\n   */\n  stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    clearTimeout(this.keepaliveTimeoutId);\n  }\n  createSession(proxyConnectionResult) {\n    var _a, _b, _c;\n    if (proxyConnectionResult.realTarget) {\n      this.remoteName = (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget);\n      this.trace('creating HTTP/2 session through proxy to ' + proxyConnectionResult.realTarget);\n    } else {\n      this.remoteName = null;\n      this.trace('creating HTTP/2 session');\n    }\n    const targetAuthority = (0, resolver_1.getDefaultAuthority)((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n    let connectionOptions = this.credentials._getConnectionOptions() || {};\n    connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n    if ('grpc-node.max_session_memory' in this.options) {\n      connectionOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n    } else {\n      /* By default, set a very large max session memory limit, to effectively\n       * disable enforcement of the limit. Some testing indicates that Node's\n       * behavior degrades badly when this limit is reached, so we solve that\n       * by disabling the check entirely. */\n      connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n    }\n    let addressScheme = 'http://';\n    if ('secureContext' in connectionOptions) {\n      addressScheme = 'https://';\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        const authorityHostname = (_c = (_b = (0, uri_parser_1.splitHostPort)(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'localhost';\n        // We want to always set servername to support SNI\n        connectionOptions.servername = authorityHostname;\n      }\n      if (proxyConnectionResult.socket) {\n        /* This is part of the workaround for\n         * https://github.com/nodejs/node/issues/32922. Without that bug,\n         * proxyConnectionResult.socket would always be a plaintext socket and\n         * this would say\n         * connectionOptions.socket = proxyConnectionResult.socket; */\n        connectionOptions.createConnection = (authority, option) => {\n          return proxyConnectionResult.socket;\n        };\n      }\n    } else {\n      /* In all but the most recent versions of Node, http2.connect does not use\n       * the options when establishing plaintext connections, so we need to\n       * establish that connection explicitly. */\n      connectionOptions.createConnection = (authority, option) => {\n        if (proxyConnectionResult.socket) {\n          return proxyConnectionResult.socket;\n        } else {\n          /* net.NetConnectOpts is declared in a way that is more restrictive\n           * than what net.connect will actually accept, so we use the type\n           * assertion to work around that. */\n          return net.connect(this.subchannelAddress);\n        }\n      };\n    }\n    connectionOptions = Object.assign(Object.assign({}, connectionOptions), this.subchannelAddress);\n    /* http2.connect uses the options here:\n     * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n     * The spread operator overides earlier values with later ones, so any port\n     * or host values in the options will be used rather than any values extracted\n     * from the first argument. In addition, the path overrides the host and port,\n     * as documented for plaintext connections here:\n     * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n     * and for TLS connections here:\n     * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n     * earlier versions of Node, http2.connect passes these options to\n     * tls.connect but not net.connect, so in the insecure case we still need\n     * to set the createConnection option above to create the connection\n     * explicitly. We cannot do that in the TLS case because http2.connect\n     * passes necessary additional options to tls.connect.\n     * The first argument just needs to be parseable as a URL and the scheme\n     * determines whether the connection will be established over TLS or not.\n     */\n    const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n    this.session = session;\n    this.channelzSocketRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzSocketInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.childrenTracker.refChild(this.channelzSocketRef);\n    }\n    session.unref();\n    /* For all of these events, check if the session at the time of the event\n     * is the same one currently attached to this subchannel, to ensure that\n     * old events from previous connection attempts cannot cause invalid state\n     * transitions. */\n    session.once('connect', () => {\n      if (this.session === session) {\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY);\n      }\n    });\n    session.once('close', () => {\n      if (this.session === session) {\n        this.trace('connection closed');\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        /* Transitioning directly to IDLE here should be OK because we are not\n         * doing any backoff, because a connection was established at some\n         * point */\n        this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      }\n    });\n    session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n      if (this.session === session) {\n        /* See the last paragraph of\n         * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n        if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {\n          this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);\n          logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTimeMs} ms`);\n        }\n        this.trace('connection closed by GOAWAY with code ' + errorCode);\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      }\n    });\n    session.once('error', error => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace('connection closed with error ' + error.message);\n    });\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', settings => {\n        this.trace('new settings received' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n      session.on('localSettings', settings => {\n        this.trace('local settings acknowledged by remote' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n    }\n  }\n  startConnectingInternal() {\n    var _a, _b;\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions = this.credentials._getConnectionOptions() || {};\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in this.options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = (0, resolver_1.getDefaultAuthority)((_a = (0, uri_parser_1.parseUri)(this.options['grpc.http_connect_target'])) !== null && _a !== void 0 ? _a : {\n            path: 'localhost'\n          });\n          const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n          connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n        }\n      }\n    }\n    (0, http_proxy_1.getProxiedConnection)(this.subchannelAddress, this.options, connectionOptions).then(result => {\n      this.createSession(result);\n    }, reason => {\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    });\n  }\n  handleDisconnect() {\n    this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    for (const listener of this.disconnectListeners.values()) {\n      listener();\n    }\n  }\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  transitionToState(oldStates, newState) {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case connectivity_state_1.ConnectivityState.READY:\n        this.stopBackoff();\n        const session = this.session;\n        session.socket.once('close', () => {\n          if (this.session === session) {\n            this.handleDisconnect();\n          }\n        });\n        if (this.keepaliveWithoutCalls) {\n          this.startKeepalivePings();\n        }\n        break;\n      case connectivity_state_1.ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case connectivity_state_1.ConnectivityState.IDLE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    /* We use a shallow copy of the stateListeners array in case a listener\n     * is removed during this iteration */\n    for (const listener of [...this.stateListeners]) {\n      listener(this, previousState, newState);\n    }\n    return true;\n  }\n  /**\n   * Check if the subchannel associated with zero calls and with zero channels.\n   * If so, shut it down.\n   */\n  checkBothRefcounts() {\n    /* If no calls, channels, or subchannel pools have any more references to\n     * this subchannel, we can be sure it will never be used again. */\n    if (this.callRefcount === 0 && this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      if (this.channelzEnabled) {\n        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n      }\n    }\n  }\n  callRef() {\n    this.refTrace('callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount + 1));\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.ref();\n      }\n      this.backoffTimeout.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.startKeepalivePings();\n      }\n    }\n    this.callRefcount += 1;\n  }\n  callUnref() {\n    this.refTrace('callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount - 1));\n    this.callRefcount -= 1;\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.unref();\n      }\n      this.backoffTimeout.unref();\n      if (!this.keepaliveWithoutCalls) {\n        clearInterval(this.keepaliveIntervalId);\n      }\n      this.checkBothRefcounts();\n    }\n  }\n  ref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n    this.refcount += 1;\n  }\n  unref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n    this.refcount -= 1;\n    this.checkBothRefcounts();\n  }\n  unrefIfOneRef() {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n  createCall(metadata, host, method, listener) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = host;\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = method;\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session.request(headers);\n    } catch (e) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n      throw e;\n    }\n    this.flowControlTrace('local window size: ' + this.session.state.localWindowSize + ' remote window size: ' + this.session.state.remoteWindowSize);\n    const streamSession = this.session;\n    this.internalsTrace('session.closed=' + streamSession.closed + ' session.destroyed=' + streamSession.destroyed + ' session.socket.destroyed=' + streamSession.socket.destroyed);\n    let statsTracker;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      this.streamTracker.addCallStarted();\n      statsTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n        },\n        onCallEnd: status => {\n          if (status.code === constants_1.Status.OK) {\n            this.callTracker.addCallSucceeded();\n          } else {\n            this.callTracker.addCallFailed();\n          }\n        },\n        onStreamEnd: success => {\n          if (streamSession === this.session) {\n            if (success) {\n              this.streamTracker.addCallSucceeded();\n            } else {\n              this.streamTracker.addCallFailed();\n            }\n          }\n        }\n      };\n    } else {\n      statsTracker = {\n        addMessageSent: () => {},\n        addMessageReceived: () => {},\n        onCallEnd: () => {},\n        onStreamEnd: () => {}\n      };\n    }\n    return new subchannel_call_1.Http2SubchannelCall(http2Stream, statsTracker, listener, this, (0, call_number_1.getNextCallNumber)());\n  }\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    /* First, try to transition from IDLE to connecting. If that doesn't happen\n     * because the state is not currently IDLE, check if it is\n     * TRANSIENT_FAILURE, and if so indicate that it should go back to\n     * connecting after the backoff timer ends. Otherwise do nothing */\n    if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\n      if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        this.continueConnecting = true;\n      }\n    }\n  }\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener) {\n    this.stateListeners.push(listener);\n  }\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n  addDisconnectListener(listener) {\n    this.disconnectListeners.add(listener);\n  }\n  removeDisconnectListener(listener) {\n    this.disconnectListeners.delete(listener);\n  }\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n  }\n  getAddress() {\n    return this.subchannelAddressString;\n  }\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  getRealSubchannel() {\n    return this;\n  }\n}\nexports.Subchannel = Subchannel;","map":{"version":3,"mappings":"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","names":["clientVersion","require","version","TRACER_NAME","FLOW_CONTROL_TRACER_NAME","KEEPALIVE_MAX_TIME_MS","KEEPALIVE_TIMEOUT_MS","HTTP2_HEADER_AUTHORITY","HTTP2_HEADER_CONTENT_TYPE","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_HEADER_TE","HTTP2_HEADER_USER_AGENT","http2","constants","tooManyPingsData","Buffer","from","Subchannel","constructor","channelTarget","subchannelAddress","options","credentials","connectivity_state_1","IDLE","Set","channelz_1","userAgent","filter","e","join","keepaliveTimeMs","keepaliveTimeoutMs","keepaliveWithoutCalls","keepaliveIntervalId","setTimeout","clearTimeout","keepaliveTimeoutId","backoffOptions","initialDelay","maxDelay","backoffTimeout","backoff_timeout_1","handleBackoffTimer","subchannelAddressString","channelzEnabled","channelzTrace","channelzRef","getChannelzInfo","addTrace","trace","JSON","stringify","undefined","state","connectivityState","callTracker","children","childrenTracker","getChildLists","target","getChannelzSocketInfo","session","sessionSocket","socket","remoteAddress","remotePort","localAddress","localPort","tlsInfo","encrypted","tlsSocket","cipherInfo","getCipher","certificate","getCertificate","peerCertificate","getPeerCertificate","cipherSuiteStandardName","standardName","cipherSuiteOtherName","name","localCertificate","raw","remoteCertificate","socketInfo","security","remoteName","streamsStarted","streamTracker","callsStarted","streamsSucceeded","callsSucceeded","streamsFailed","callsFailed","messagesSent","messagesReceived","keepAlivesSent","keepalivesSent","lastLocalStreamCreatedTimestamp","lastCallStartedTimestamp","lastRemoteStreamCreatedTimestamp","lastMessageSentTimestamp","lastMessageReceivedTimestamp","localFlowControlWindow","localWindowSize","remoteFlowControlWindow","remoteWindowSize","resetChannelzSocketInfo","channelzSocketRef","unrefChild","text","logging","constants_1","DEBUG","id","refTrace","flowControlTrace","internalsTrace","keepaliveTrace","continueConnecting","transitionToState","TRANSIENT_FAILURE","CONNECTING","startBackoff","runOnce","stopBackoff","stop","reset","sendPing","handleDisconnect","unref","ping","err","duration","payload","READY","startKeepalivePings","setInterval","stopKeepalivePings","clearInterval","createSession","proxyConnectionResult","realTarget","targetAuthority","connectionOptions","_getConnectionOptions","maxSendHeaderBlockLength","Number","MAX_SAFE_INTEGER","maxSessionMemory","addressScheme","sslTargetNameOverride","checkServerIdentity","host","cert","servername","authorityHostname","createConnection","authority","option","net","connect","refChild","once","errorCode","lastStreamID","opaqueData","NGHTTP2_ENHANCE_YOUR_CALM","equals","Math","min","log","ERROR","error","message","isTracerEnabled","on","settings","startConnectingInternal","ALPNProtocols","targetPath","path","hostPort","then","result","reason","listener","disconnectListeners","values","oldStates","newState","indexOf","previousState","close","isRunning","process","nextTick","Error","stateListeners","checkBothRefcounts","callRefcount","refcount","callRef","ref","callUnref","unrefIfOneRef","createCall","metadata","method","headers","toHttp2Headers","http2Stream","request","streamSession","closed","destroyed","statsTracker","addCallStarted","addMessageSent","Date","addMessageReceived","onCallEnd","status","code","OK","addCallSucceeded","addCallFailed","onStreamEnd","success","subchannel_call_1","startConnecting","getConnectivityState","addConnectivityStateListener","push","removeConnectivityStateListener","listenerIndex","splice","addDisconnectListener","add","removeDisconnectListener","delete","resetBackoff","getAddress","getChannelzRef","getRealSubchannel","exports"],"sources":["E:\\React\\face-app\\node_modules\\@grpc\\grpc-js\\src\\subchannel.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport { ChannelCredentials } from './channel-credentials';\nimport { Metadata } from './metadata';\nimport { ChannelOptions } from './channel-options';\nimport { PeerCertificate, checkServerIdentity, TLSSocket, CipherNameAndProtocol } from 'tls';\nimport { ConnectivityState } from './connectivity-state';\nimport { BackoffTimeout, BackoffOptions } from './backoff-timeout';\nimport { getDefaultAuthority } from './resolver';\nimport * as logging from './logging';\nimport { LogVerbosity, Status } from './constants';\nimport { getProxiedConnection, ProxyConnectionResult } from './http_proxy';\nimport * as net from 'net';\nimport { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';\nimport { ConnectionOptions } from 'tls';\nimport {\n  stringToSubchannelAddress,\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport { SubchannelRef, ChannelzTrace, ChannelzChildrenTracker, SubchannelInfo, registerChannelzSubchannel, ChannelzCallTracker, SocketInfo, SocketRef, unregisterChannelzRef, registerChannelzSocket, TlsInfo } from './channelz';\nimport { ConnectivityStateListener } from './subchannel-interface';\nimport { Http2SubchannelCall, SubchannelCallInterceptingListener } from './subchannel-call';\nimport { getNextCallNumber } from './call-number';\nimport { SubchannelCall } from './subchannel-call';\nimport { InterceptingListener, StatusObject } from './call-interface';\n\nconst clientVersion = require('../../package.json').version;\n\nconst TRACER_NAME = 'subchannel';\nconst FLOW_CONTROL_TRACER_NAME = 'subchannel_flowctrl';\n\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\n\nexport interface SubchannelCallStatsTracker {\n  addMessageSent(): void;\n  addMessageReceived(): void;\n  onCallEnd(status: StatusObject): void;\n  onStreamEnd(success: boolean): void;\n}\n\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT,\n} = http2.constants;\n\nconst tooManyPingsData: Buffer = Buffer.from('too_many_pings', 'ascii');\n\nexport class Subchannel {\n  /**\n   * The subchannel's current connectivity state. Invariant: `session` === `null`\n   * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n   */\n  private connectivityState: ConnectivityState = ConnectivityState.IDLE;\n  /**\n   * The underlying http2 session used to make requests.\n   */\n  private session: http2.ClientHttp2Session | null = null;\n  /**\n   * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n   * CONNECTING instead of IDLE when the backoff timeout ends.\n   */\n  private continueConnecting = false;\n  /**\n   * A list of listener functions that will be called whenever the connectivity\n   * state changes. Will be modified by `addConnectivityStateListener` and\n   * `removeConnectivityStateListener`\n   */\n  private stateListeners: ConnectivityStateListener[] = [];\n\n  /**\n   * A list of listener functions that will be called when the underlying\n   * socket disconnects. Used for ending active calls with an UNAVAILABLE\n   * status.\n   */\n  private disconnectListeners: Set<() => void> = new Set();\n\n  private backoffTimeout: BackoffTimeout;\n\n  /**\n   * The complete user agent string constructed using channel args.\n   */\n  private userAgent: string;\n\n  /**\n   * The amount of time in between sending pings\n   */\n  private keepaliveTimeMs: number = KEEPALIVE_MAX_TIME_MS;\n  /**\n   * The amount of time to wait for an acknowledgement after sending a ping\n   */\n  private keepaliveTimeoutMs: number = KEEPALIVE_TIMEOUT_MS;\n  /**\n   * Timer reference for timeout that indicates when to send the next ping\n   */\n  private keepaliveIntervalId: NodeJS.Timer;\n  /**\n   * Timer reference tracking when the most recent ping will be considered lost\n   */\n  private keepaliveTimeoutId: NodeJS.Timer;\n  /**\n   * Indicates whether keepalive pings should be sent without any active calls\n   */\n  private keepaliveWithoutCalls = false;\n\n  /**\n   * Tracks calls with references to this subchannel\n   */\n  private callRefcount = 0;\n  /**\n   * Tracks channels and subchannel pools with references to this subchannel\n   */\n  private refcount = 0;\n\n  /**\n   * A string representation of the subchannel address, for logging/tracing\n   */\n  private subchannelAddressString: string;\n\n  // Channelz info\n  private readonly channelzEnabled: boolean = true;\n  private channelzRef: SubchannelRef;\n  private channelzTrace: ChannelzTrace;\n  private callTracker = new ChannelzCallTracker();\n  private childrenTracker = new ChannelzChildrenTracker();\n\n  // Channelz socket info\n  private channelzSocketRef: SocketRef | null = null;\n  /**\n   * Name of the remote server, if it is not the same as the subchannel\n   * address, i.e. if connecting through an HTTP CONNECT proxy.\n   */\n  private remoteName: string | null = null;\n  private streamTracker = new ChannelzCallTracker();\n  private keepalivesSent = 0;\n  private messagesSent = 0;\n  private messagesReceived = 0;\n  private lastMessageSentTimestamp: Date | null = null;\n  private lastMessageReceivedTimestamp: Date | null = null;\n\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(\n    private channelTarget: GrpcUri,\n    private subchannelAddress: SubchannelAddress,\n    private options: ChannelOptions,\n    private credentials: ChannelCredentials\n  ) {\n    // Build user-agent string.\n    this.userAgent = [\n      options['grpc.primary_user_agent'],\n      `grpc-node-js/${clientVersion}`,\n      options['grpc.secondary_user_agent'],\n    ]\n      .filter((e) => e)\n      .join(' '); // remove falsey values first\n\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms']!;\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms']!;\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls =\n        options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    this.keepaliveTimeoutId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveTimeoutId);\n    const backoffOptions: BackoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms'],\n    };\n    this.backoffTimeout = new BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new ChannelzTrace();\n    this.channelzRef = registerChannelzSubchannel(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    }\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n\n  private getChannelzInfo(): SubchannelInfo {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n\n  private getChannelzSocketInfo(): SocketInfo | null {\n    if (this.session === null) {\n      return null;\n    }\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo: TlsInfo | null;\n    if (this.session.encrypted) {\n      const tlsSocket: TLSSocket = sessionSocket as TLSSocket;\n      const cipherInfo: CipherNameAndProtocol & {standardName?: string} = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: cipherInfo.standardName ?? null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: (certificate && 'raw' in certificate) ? certificate.raw : null,\n        remoteCertificate: (peerCertificate && 'raw' in peerCertificate) ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo: SocketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: this.session.state.localWindowSize ?? null,\n      remoteFlowControlWindow: this.session.state.remoteWindowSize ?? null\n    };\n    return socketInfo;\n  }\n\n  private resetChannelzSocketInfo() {\n    if (!this.channelzEnabled) {\n      return;\n    }\n    if (this.channelzSocketRef) {\n      unregisterChannelzRef(this.channelzSocketRef);\n      this.childrenTracker.unrefChild(this.channelzSocketRef);\n      this.channelzSocketRef = null;\n    }\n    this.remoteName = null;\n    this.streamTracker = new ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n  }\n\n  private trace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private refTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private flowControlTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private internalsTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'subchannel_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private keepaliveTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.CONNECTING\n      );\n    } else {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.IDLE\n      );\n    }\n  }\n\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  private startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n\n  private stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n\n  private sendPing() {\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n    this.keepaliveTimeoutId = setTimeout(() => {\n      this.keepaliveTrace('Ping timeout passed without response');\n      this.handleDisconnect();\n    }, this.keepaliveTimeoutMs);\n    this.keepaliveTimeoutId.unref?.();\n    try {\n      this.session!.ping(\n        (err: Error | null, duration: number, payload: Buffer) => {\n          this.keepaliveTrace('Received ping response');\n          clearTimeout(this.keepaliveTimeoutId);\n        }\n      );\n    } catch (e) {\n      /* If we fail to send a ping, the connection is no longer functional, so\n       * we should discard it. */\n      this.transitionToState(\n        [ConnectivityState.READY],\n        ConnectivityState.TRANSIENT_FAILURE\n      );\n    }\n  }\n\n  private startKeepalivePings() {\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    this.keepaliveIntervalId.unref?.();\n    /* Don't send a ping immediately because whatever caused us to start\n     * sending pings should also involve some network activity. */\n  }\n\n  /**\n   * Stop keepalive pings when terminating a connection. This discards the\n   * outstanding ping timeout, so it should not be called if the same\n   * connection will still be used.\n   */\n  private stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    clearTimeout(this.keepaliveTimeoutId);\n  }\n\n  private createSession(proxyConnectionResult: ProxyConnectionResult) {\n    if (proxyConnectionResult.realTarget) {\n      this.remoteName = uriToString(proxyConnectionResult.realTarget);\n      this.trace('creating HTTP/2 session through proxy to ' + proxyConnectionResult.realTarget);\n    } else {\n      this.remoteName = null;\n      this.trace('creating HTTP/2 session');\n    }\n    const targetAuthority = getDefaultAuthority(\n      proxyConnectionResult.realTarget ?? this.channelTarget\n    );\n    let connectionOptions: http2.SecureClientSessionOptions =\n      this.credentials._getConnectionOptions() || {};\n    connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n    if ('grpc-node.max_session_memory' in this.options) {\n      connectionOptions.maxSessionMemory = this.options[\n        'grpc-node.max_session_memory'\n      ];\n    } else {\n      /* By default, set a very large max session memory limit, to effectively\n       * disable enforcement of the limit. Some testing indicates that Node's\n       * behavior degrades badly when this limit is reached, so we solve that\n       * by disabling the check entirely. */\n      connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n    }\n    let addressScheme = 'http://';\n    if ('secureContext' in connectionOptions) {\n      addressScheme = 'https://';\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options[\n          'grpc.ssl_target_name_override'\n        ]!;\n        connectionOptions.checkServerIdentity = (\n          host: string,\n          cert: PeerCertificate\n        ): Error | undefined => {\n          return checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        const authorityHostname =\n          splitHostPort(targetAuthority)?.host ?? 'localhost';\n        // We want to always set servername to support SNI\n        connectionOptions.servername = authorityHostname;\n      }\n      if (proxyConnectionResult.socket) {\n        /* This is part of the workaround for\n         * https://github.com/nodejs/node/issues/32922. Without that bug,\n         * proxyConnectionResult.socket would always be a plaintext socket and\n         * this would say\n         * connectionOptions.socket = proxyConnectionResult.socket; */\n        connectionOptions.createConnection = (authority, option) => {\n          return proxyConnectionResult.socket!;\n        };\n      }\n    } else {\n      /* In all but the most recent versions of Node, http2.connect does not use\n       * the options when establishing plaintext connections, so we need to\n       * establish that connection explicitly. */\n      connectionOptions.createConnection = (authority, option) => {\n        if (proxyConnectionResult.socket) {\n          return proxyConnectionResult.socket;\n        } else {\n          /* net.NetConnectOpts is declared in a way that is more restrictive\n           * than what net.connect will actually accept, so we use the type\n           * assertion to work around that. */\n          return net.connect(this.subchannelAddress);\n        }\n      };\n    }\n\n    connectionOptions = {\n      ...connectionOptions,\n      ...this.subchannelAddress,\n    };\n\n    /* http2.connect uses the options here:\n     * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n     * The spread operator overides earlier values with later ones, so any port\n     * or host values in the options will be used rather than any values extracted\n     * from the first argument. In addition, the path overrides the host and port,\n     * as documented for plaintext connections here:\n     * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n     * and for TLS connections here:\n     * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n     * earlier versions of Node, http2.connect passes these options to\n     * tls.connect but not net.connect, so in the insecure case we still need\n     * to set the createConnection option above to create the connection\n     * explicitly. We cannot do that in the TLS case because http2.connect\n     * passes necessary additional options to tls.connect.\n     * The first argument just needs to be parseable as a URL and the scheme\n     * determines whether the connection will be established over TLS or not.\n     */\n    const session = http2.connect(\n      addressScheme + targetAuthority,\n      connectionOptions\n    );\n    this.session = session;\n    this.channelzSocketRef = registerChannelzSocket(this.subchannelAddressString, () => this.getChannelzSocketInfo()!, this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.childrenTracker.refChild(this.channelzSocketRef);\n    }\n    session.unref();\n    /* For all of these events, check if the session at the time of the event\n     * is the same one currently attached to this subchannel, to ensure that\n     * old events from previous connection attempts cannot cause invalid state\n     * transitions. */\n    session.once('connect', () => {\n      if (this.session === session) {\n        this.transitionToState(\n          [ConnectivityState.CONNECTING],\n          ConnectivityState.READY\n        );\n      }\n    });\n    session.once('close', () => {\n      if (this.session === session) {\n        this.trace('connection closed');\n        this.transitionToState(\n          [ConnectivityState.CONNECTING],\n          ConnectivityState.TRANSIENT_FAILURE\n        );\n        /* Transitioning directly to IDLE here should be OK because we are not\n         * doing any backoff, because a connection was established at some\n         * point */\n        this.transitionToState(\n          [ConnectivityState.READY],\n          ConnectivityState.IDLE\n        );\n      }\n    });\n    session.once(\n      'goaway',\n      (errorCode: number, lastStreamID: number, opaqueData: Buffer) => {\n        if (this.session === session) {\n          /* See the last paragraph of\n           * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n          if (\n            errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\n            opaqueData.equals(tooManyPingsData)\n          ) {\n            this.keepaliveTimeMs = Math.min(\n              2 * this.keepaliveTimeMs,\n              KEEPALIVE_MAX_TIME_MS\n            );\n            logging.log(\n              LogVerbosity.ERROR,\n              `Connection to ${uriToString(this.channelTarget)} at ${\n                this.subchannelAddressString\n              } rejected by server because of excess pings. Increasing ping interval to ${\n                this.keepaliveTimeMs\n              } ms`\n            );\n          }\n          this.trace(\n            'connection closed by GOAWAY with code ' +\n              errorCode\n          );\n          this.transitionToState(\n            [ConnectivityState.CONNECTING, ConnectivityState.READY],\n            ConnectivityState.IDLE\n          );\n        }\n      }\n    );\n    session.once('error', (error) => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace(\n        'connection closed with error ' +\n          (error as Error).message\n      );\n    });\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', (settings: http2.Settings) => {\n        this.trace(\n          'new settings received' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n      session.on('localSettings', (settings: http2.Settings) => {\n        this.trace(\n          'local settings acknowledged by remote' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n    }\n  }\n\n  private startConnectingInternal() {\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions: ConnectionOptions =\n      this.credentials._getConnectionOptions() || {};\n\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options[\n          'grpc.ssl_target_name_override'\n        ]!;\n        connectionOptions.checkServerIdentity = (\n          host: string,\n          cert: PeerCertificate\n        ): Error | undefined => {\n          return checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in this.options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = getDefaultAuthority(\n            parseUri(this.options['grpc.http_connect_target'] as string) ?? {\n              path: 'localhost',\n            }\n          );\n          const hostPort = splitHostPort(targetPath);\n          connectionOptions.servername = hostPort?.host ?? targetPath;\n        }\n      }\n    }\n\n    getProxiedConnection(\n      this.subchannelAddress,\n      this.options,\n      connectionOptions\n    ).then(\n      (result) => {\n        this.createSession(result);\n      },\n      (reason) => {\n        this.transitionToState(\n          [ConnectivityState.CONNECTING],\n          ConnectivityState.TRANSIENT_FAILURE\n        );\n      }\n    );\n  }\n\n  private handleDisconnect() {\n    this.transitionToState(\n      [ConnectivityState.READY],\n      ConnectivityState.TRANSIENT_FAILURE);\n    for (const listener of this.disconnectListeners.values()) {\n      listener();\n    }\n  }\n\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  private transitionToState(\n    oldStates: ConnectivityState[],\n    newState: ConnectivityState\n  ): boolean {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    this.trace(\n      ConnectivityState[this.connectivityState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case ConnectivityState.READY:\n        this.stopBackoff();\n        const session = this.session!;\n        session.socket.once('close', () => {\n          if (this.session === session) {\n            this.handleDisconnect();\n          }\n        });\n        if (this.keepaliveWithoutCalls) {\n          this.startKeepalivePings();\n        }\n        break;\n      case ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case ConnectivityState.TRANSIENT_FAILURE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case ConnectivityState.IDLE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    /* We use a shallow copy of the stateListeners array in case a listener\n     * is removed during this iteration */\n    for (const listener of [...this.stateListeners]) {\n      listener(this, previousState, newState);\n    }\n    return true;\n  }\n\n  /**\n   * Check if the subchannel associated with zero calls and with zero channels.\n   * If so, shut it down.\n   */\n  private checkBothRefcounts() {\n    /* If no calls, channels, or subchannel pools have any more references to\n     * this subchannel, we can be sure it will never be used again. */\n    if (this.callRefcount === 0 && this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n      this.transitionToState(\n        [ConnectivityState.CONNECTING, ConnectivityState.READY],\n        ConnectivityState.IDLE\n      );\n      if (this.channelzEnabled) {\n        unregisterChannelzRef(this.channelzRef);\n      }\n    }\n  }\n\n  callRef() {\n    this.refTrace(\n      'callRefcount ' +\n        this.callRefcount +\n        ' -> ' +\n        (this.callRefcount + 1)\n    );\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.ref();\n      }\n      this.backoffTimeout.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.startKeepalivePings();\n      }\n    }\n    this.callRefcount += 1;\n  }\n\n  callUnref() {\n    this.refTrace(\n      'callRefcount ' +\n        this.callRefcount +\n        ' -> ' +\n        (this.callRefcount - 1)\n    );\n    this.callRefcount -= 1;\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.unref();\n      }\n      this.backoffTimeout.unref();\n      if (!this.keepaliveWithoutCalls) {\n        clearInterval(this.keepaliveIntervalId);\n      }\n      this.checkBothRefcounts();\n    }\n  }\n\n  ref() {\n    this.refTrace(\n      'refcount ' +\n        this.refcount +\n        ' -> ' +\n        (this.refcount + 1)\n    );\n    this.refcount += 1;\n  }\n\n  unref() {\n    this.refTrace(\n      'refcount ' +\n        this.refcount +\n        ' -> ' +\n        (this.refcount - 1)\n    );\n    this.refcount -= 1;\n    this.checkBothRefcounts();\n  }\n\n  unrefIfOneRef(): boolean {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n\n  createCall(metadata: Metadata, host: string, method: string, listener: SubchannelCallInterceptingListener): SubchannelCall {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = host;\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = method;\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream: http2.ClientHttp2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session!.request(headers);\n    } catch (e) {\n      this.transitionToState(\n        [ConnectivityState.READY],\n        ConnectivityState.TRANSIENT_FAILURE\n      );\n      throw e;\n    }\n    this.flowControlTrace(\n      'local window size: ' +\n        this.session!.state.localWindowSize +\n        ' remote window size: ' +\n        this.session!.state.remoteWindowSize\n    );\n    const streamSession = this.session;\n    this.internalsTrace(\n      'session.closed=' + \n      streamSession!.closed + \n      ' session.destroyed=' + \n      streamSession!.destroyed + \n      ' session.socket.destroyed=' + \n      streamSession!.socket.destroyed);\n    let statsTracker: SubchannelCallStatsTracker;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      this.streamTracker.addCallStarted();\n      statsTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n        },\n        onCallEnd: status => {\n          if (status.code === Status.OK) {\n            this.callTracker.addCallSucceeded();\n          } else {\n            this.callTracker.addCallFailed();\n          }\n        },\n        onStreamEnd: success => {\n          if (streamSession === this.session) {\n            if (success) {\n              this.streamTracker.addCallSucceeded();\n            } else {\n              this.streamTracker.addCallFailed();\n            }\n          }\n        }\n      }\n    } else {\n      statsTracker = {\n        addMessageSent: () => {},\n        addMessageReceived: () => {},\n        onCallEnd: () => {},\n        onStreamEnd: () => {}\n      }\n    }\n    return new Http2SubchannelCall(http2Stream, statsTracker, listener, this, getNextCallNumber());\n  }\n\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    /* First, try to transition from IDLE to connecting. If that doesn't happen\n     * because the state is not currently IDLE, check if it is\n     * TRANSIENT_FAILURE, and if so indicate that it should go back to\n     * connecting after the backoff timer ends. Otherwise do nothing */\n    if (\n      !this.transitionToState(\n        [ConnectivityState.IDLE],\n        ConnectivityState.CONNECTING\n      )\n    ) {\n      if (this.connectivityState === ConnectivityState.TRANSIENT_FAILURE) {\n        this.continueConnecting = true;\n      }\n    }\n  }\n\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener: ConnectivityStateListener) {\n    this.stateListeners.push(listener);\n  }\n\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener: ConnectivityStateListener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  addDisconnectListener(listener: () => void) {\n    this.disconnectListeners.add(listener);\n  }\n\n  removeDisconnectListener(listener: () => void) {\n    this.disconnectListeners.delete(listener);\n  }\n\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.transitionToState(\n      [ConnectivityState.TRANSIENT_FAILURE],\n      ConnectivityState.CONNECTING\n    );\n  }\n\n  getAddress(): string {\n    return this.subchannelAddressString;\n  }\n\n  getChannelzRef(): SubchannelRef {\n    return this.channelzRef;\n  }\n\n  getRealSubchannel(): this {\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}